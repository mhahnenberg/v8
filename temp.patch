diff --git a/BUILD.gn b/BUILD.gn
index cffd0456c8..c4fb4bfcc4 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -2908,6 +2908,10 @@ v8_source_set("v8_base_without_compiler") {
     "src/parsing/parser.cc",
     "src/parsing/parser.h",
     "src/parsing/parsing.cc",
+    "src/parsing/binast-parser.h",
+    "src/parsing/binast-parser.cc",
+    "src/parsing/binast.h",
+    "src/parsing/binast.cc",
     "src/parsing/parsing.h",
     "src/parsing/pending-compilation-error-handler.cc",
     "src/parsing/pending-compilation-error-handler.h",
@@ -4322,6 +4326,40 @@ if (current_toolchain == v8_snapshot_toolchain) {
   }
 }
 
+v8_executable("test_binast") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+
+    sources = [
+      "src/snapshot/embedded/embedded-empty.cc",
+      "src/snapshot/embedded/embedded-file-writer.cc",
+      "src/snapshot/embedded/embedded-file-writer.h",
+      # "src/snapshot/embedded/platform-embedded-file-writer-aix.cc",
+      # "src/snapshot/embedded/platform-embedded-file-writer-aix.h",
+      # "src/snapshot/embedded/platform-embedded-file-writer-base.cc",
+      # "src/snapshot/embedded/platform-embedded-file-writer-base.h",
+      # "src/snapshot/embedded/platform-embedded-file-writer-generic.cc",
+      # "src/snapshot/embedded/platform-embedded-file-writer-generic.h",
+      # "src/snapshot/embedded/platform-embedded-file-writer-mac.cc",
+      # "src/snapshot/embedded/platform-embedded-file-writer-mac.h",
+      # "src/snapshot/embedded/platform-embedded-file-writer-win.cc",
+      # "src/snapshot/embedded/platform-embedded-file-writer-win.h",
+      "src/parsing/test_binast.cc",
+      # "src/snapshot/snapshot-empty.cc",
+      "src/snapshot/snapshot-empty.cc",
+    ]
+
+    configs = [ ":internal_config" ]
+
+    deps = [
+      ":v8_base",
+      ":v8_init",
+      ":v8_libbase",
+      ":v8_libplatform",
+      ":v8_maybe_icu",
+      ":v8_tracing",
+    ]
+}
+
 if (current_toolchain == v8_snapshot_toolchain) {
   v8_executable("torque") {
     visibility = [ ":*" ]  # Only targets in this file can depend on this.
diff --git a/src/ast/ast-function-literal-id-reindexer.cc b/src/ast/ast-function-literal-id-reindexer.cc
index b583b5e421..84488c698a 100644
--- a/src/ast/ast-function-literal-id-reindexer.cc
+++ b/src/ast/ast-function-literal-id-reindexer.cc
@@ -96,6 +96,8 @@ class AstFunctionLiteralIdReindexChecker final
     // here, but that requires more advanced DCHECK support with formatting.
     DCHECK(visited_->find(lit) != visited_->end());
   }
+  bool VisitDeclaration(VariableDeclaration* decl) { return true; }
+  bool VisitDeclaration(FunctionDeclaration* decl) { return true; }
 
  private:
   const std::set<FunctionLiteral*>* visited_;
diff --git a/src/ast/ast-function-literal-id-reindexer.h b/src/ast/ast-function-literal-id-reindexer.h
index f4dac7b01e..3ea7980341 100644
--- a/src/ast/ast-function-literal-id-reindexer.h
+++ b/src/ast/ast-function-literal-id-reindexer.h
@@ -28,6 +28,8 @@ class AstFunctionLiteralIdReindexer final
   // AstTraversalVisitor implementation.
   void VisitFunctionLiteral(FunctionLiteral* lit);
   void VisitClassLiteral(ClassLiteral* lit);
+  bool VisitDeclaration(VariableDeclaration* decl) { return true; }
+  bool VisitDeclaration(FunctionDeclaration* decl) { return true; }
 
  private:
   int delta_;
diff --git a/src/ast/ast-traversal-visitor.h b/src/ast/ast-traversal-visitor.h
index 8a1f8b2f16..ed4ed098be 100644
--- a/src/ast/ast-traversal-visitor.h
+++ b/src/ast/ast-traversal-visitor.h
@@ -41,6 +41,9 @@ class AstTraversalVisitor : public AstVisitor<Subclass> {
 
   // Iteration left-to-right.
   void VisitDeclarations(Declaration::List* declarations);
+  void VisitDeclaration(Declaration* declaration);
+  void VisitVariableDeclaration(VariableDeclaration* declaration);
+  void VisitFunctionDeclaration(FunctionDeclaration* declaration);
   void VisitStatements(const ZonePtrList<Statement>* statements);
 
 // Individual nodes
@@ -67,6 +70,10 @@ class AstTraversalVisitor : public AstVisitor<Subclass> {
     if (!(this->impl()->VisitNode(node))) return;       \
   } while (false)
 
+#define PROCESS_DECL(decl) do {                         \
+  this->impl()->VisitDeclaration(decl);                 \
+} while (false)
+
 #define PROCESS_EXPRESSION(node) do {                           \
     PROCESS_NODE(node);                                         \
     if (!(this->impl()->VisitExpression(node))) return;         \
@@ -106,7 +113,7 @@ template <class Subclass>
 void AstTraversalVisitor<Subclass>::VisitDeclarations(
     Declaration::List* decls) {
   for (Declaration* decl : *decls) {
-    RECURSE(Visit(decl));
+    VisitDeclaration(decl);
   }
 }
 
@@ -119,17 +126,35 @@ void AstTraversalVisitor<Subclass>::VisitStatements(
   }
 }
 
+template <class Subclass>
+void AstTraversalVisitor<Subclass>::VisitDeclaration(
+    Declaration* decl) {
+  switch (decl->type()) {
+    case Declaration::VariableDecl: {
+      RECURSE(VisitVariableDeclaration(static_cast<VariableDeclaration*>(decl)));
+      break;
+    }
+    case Declaration::FunctionDecl: {
+      RECURSE(VisitFunctionDeclaration(static_cast<FunctionDeclaration*>(decl)));
+      break;
+    }
+    default: {
+      UNREACHABLE();
+    }
+  }
+}
+
 template <class Subclass>
 void AstTraversalVisitor<Subclass>::VisitVariableDeclaration(
     VariableDeclaration* decl) {
-  PROCESS_NODE(decl);
+  PROCESS_DECL(decl);
 }
 
 template <class Subclass>
 void AstTraversalVisitor<Subclass>::VisitFunctionDeclaration(
     FunctionDeclaration* decl) {
-  PROCESS_NODE(decl);
-  RECURSE(Visit(decl->fun()));
+  PROCESS_DECL(decl);
+  RECURSE(Visit(decl->fun<FunctionLiteral>()));
 }
 
 template <class Subclass>
@@ -303,7 +328,7 @@ void AstTraversalVisitor<Subclass>::VisitConditional(Conditional* expr) {
 }
 
 template <class Subclass>
-void AstTraversalVisitor<Subclass>::VisitVariableProxy(VariableProxy* expr) {
+void AstTraversalVisitor<Subclass>::VisitVariableProxyExpression(VariableProxyExpression* expr) {
   PROCESS_EXPRESSION(expr);
 }
 
@@ -550,8 +575,8 @@ template <class Subclass>
 void AstTraversalVisitor<Subclass>::VisitSuperCallReference(
     SuperCallReference* expr) {
   PROCESS_EXPRESSION(expr);
-  RECURSE_EXPRESSION(VisitVariableProxy(expr->new_target_var()));
-  RECURSE_EXPRESSION(VisitVariableProxy(expr->this_function_var()));
+  RECURSE_EXPRESSION(VisitVariableProxyExpression(expr->new_target_var()));
+  RECURSE_EXPRESSION(VisitVariableProxyExpression(expr->this_function_var()));
 }
 
 #undef PROCESS_NODE
diff --git a/src/ast/ast-value-factory.h b/src/ast/ast-value-factory.h
index 134612f1fd..c77633cdd3 100644
--- a/src/ast/ast-value-factory.h
+++ b/src/ast/ast-value-factory.h
@@ -83,6 +83,8 @@ class AstRawString final : public ZoneObject {
   friend class AstRawStringInternalizationKey;
   friend class AstStringConstants;
   friend class AstValueFactory;
+  friend class BinAstValueFactory;
+  friend class BinAstStringConstants;
 
   // Members accessed only by the AstValueFactory & related classes:
   static bool Compare(void* a, void* b);
@@ -163,6 +165,7 @@ class AstConsString final : public ZoneObject {
 
  private:
   friend class AstValueFactory;
+  friend class BinAstValueFactory;
 
   AstConsString() : string_(), segment_({nullptr, nullptr}) {}
 
diff --git a/src/ast/ast.cc b/src/ast/ast.cc
index 8cd1140154..3edb227ecf 100644
--- a/src/ast/ast.cc
+++ b/src/ast/ast.cc
@@ -118,7 +118,7 @@ bool Expression::IsCompileTimeValue() {
 bool Expression::IsUndefinedLiteral() const {
   if (IsLiteral() && AsLiteral()->type() == Literal::kUndefined) return true;
 
-  const VariableProxy* var_proxy = AsVariableProxy();
+  const VariableProxyExpression* var_proxy = AsVariableProxyExpression();
   if (var_proxy == nullptr) return false;
   Variable* var = var_proxy->var();
   // The global identifier "undefined" is immutable. Everything
@@ -140,12 +140,12 @@ bool Expression::ToBooleanIsFalse() const {
 }
 
 bool Expression::IsPrivateName() const {
-  return IsVariableProxy() && AsVariableProxy()->IsPrivateName();
+  return IsVariableProxyExpression() && AsVariableProxyExpression()->IsPrivateName();
 }
 
 bool Expression::IsValidReferenceExpression() const {
   return IsProperty() ||
-         (IsVariableProxy() && AsVariableProxy()->IsValidReferenceExpression());
+         (IsVariableProxyExpression() && AsVariableProxyExpression()->IsValidReferenceExpression());
 }
 
 bool Expression::IsAnonymousFunctionDefinition() const {
@@ -164,7 +164,8 @@ bool Expression::IsAccessorFunctionDefinition() const {
 }
 
 VariableProxy::VariableProxy(Variable* var, int start_position)
-    : Expression(start_position, kVariableProxy),
+    : start_position_(start_position),
+      bit_field_(0),
       raw_name_(var->raw_name()),
       next_unresolved_(nullptr) {
   DCHECK(!var->is_this());
@@ -175,7 +176,8 @@ VariableProxy::VariableProxy(Variable* var, int start_position)
 }
 
 VariableProxy::VariableProxy(const VariableProxy* copy_from)
-    : Expression(copy_from->position(), kVariableProxy),
+    : start_position_(copy_from->position()),
+      bit_field_(0),
       next_unresolved_(nullptr) {
   bit_field_ = copy_from->bit_field_;
   DCHECK(!copy_from->is_resolved());
@@ -905,7 +907,7 @@ bool CompareOperation::IsLiteralCompareNull(Expression** expr) {
 }
 
 Call::CallType Call::GetCallType() const {
-  VariableProxy* proxy = expression()->AsVariableProxy();
+  VariableProxyExpression* proxy = expression()->AsVariableProxyExpression();
   if (proxy != nullptr) {
     if (proxy->var()->IsUnallocated()) {
       return GLOBAL_CALL;
diff --git a/src/ast/ast.h b/src/ast/ast.h
index dab3981c63..8707298100 100644
--- a/src/ast/ast.h
+++ b/src/ast/ast.h
@@ -38,9 +38,10 @@ namespace internal {
 // Nodes of the abstract syntax tree. Only concrete classes are
 // enumerated here.
 
-#define DECLARATION_NODE_LIST(V) \
-  V(VariableDeclaration)         \
-  V(FunctionDeclaration)
+// TODO(binast): Declarations are now independent of the AST
+// #define DECLARATION_NODE_LIST(V) \
+//   V(VariableDeclarationNode)     \
+//   V(FunctionDeclarationNode)
 
 #define ITERATION_NODE_LIST(V) \
   V(DoWhileStatement)          \
@@ -103,14 +104,13 @@ namespace internal {
   V(ThisExpression)             \
   V(Throw)                      \
   V(UnaryOperation)             \
-  V(VariableProxy)              \
+  V(VariableProxyExpression)    \
   V(Yield)                      \
   V(YieldStar)
 
 #define FAILURE_NODE_LIST(V) V(FailureExpression)
 
 #define AST_NODE_LIST(V)                        \
-  DECLARATION_NODE_LIST(V)                      \
   STATEMENT_NODE_LIST(V)                        \
   EXPRESSION_NODE_LIST(V)
 
@@ -350,17 +350,36 @@ class Block final : public BreakableStatement {
       : Block(nullptr, 0, ignore_completion_value, is_breakable) {}
 };
 
-class Declaration : public AstNode {
+class VariableDeclaration;
+class FunctionDeclaration;
+
+class Declaration : public ZoneObject {
  public:
+  enum DeclType : uint8_t {
+    VariableDecl,
+    FunctionDecl,
+  };
+
   using List = base::ThreadedList<Declaration>;
 
   Variable* var() const { return var_; }
   void set_var(Variable* var) { var_ = var; }
 
+  DeclType type() const { return type_; }
+  bool IsVariableDeclaration() const { return type_ == VariableDecl; }
+  bool IsFunctionDeclaration() const { return type_ == FunctionDecl; }
+
+  inline VariableDeclaration* AsVariableDeclaration();
+  inline FunctionDeclaration* AsFunctionDeclaration();
+
+  int position() const { return start_pos_; }
+
  protected:
-  Declaration(int pos, NodeType type) : AstNode(pos, type), next_(nullptr) {}
+  Declaration(int pos, DeclType type) : start_pos_(pos), type_(type), var_(nullptr), next_(nullptr) {}
 
  private:
+  int start_pos_;
+  DeclType type_;
   Variable* var_;
   // Declarations list threaded through the declarations.
   Declaration** next() { return &next_; }
@@ -371,21 +390,20 @@ class Declaration : public AstNode {
 
 class VariableDeclaration : public Declaration {
  public:
+  bool is_nested() const { return is_nested_; }
   inline NestedVariableDeclaration* AsNested();
 
  private:
   friend class AstNodeFactory;
-
-  using IsNestedField = Declaration::NextBitField<bool, 1>;
+  friend class BinAstNodeFactory;
 
  protected:
   explicit VariableDeclaration(int pos, bool is_nested = false)
-      : Declaration(pos, kVariableDeclaration) {
-    bit_field_ = IsNestedField::update(bit_field_, is_nested);
+      : Declaration(pos, Declaration::VariableDecl), is_nested_(is_nested)
+  {
   }
 
-  template <class T, int size>
-  using NextBitField = IsNestedField::Next<T, size>;
+  bool is_nested_;
 };
 
 // For var declarations that appear in a block scope.
@@ -397,6 +415,7 @@ class NestedVariableDeclaration final : public VariableDeclaration {
 
  private:
   friend class AstNodeFactory;
+  friend class BinAstNodeFactory;
 
   NestedVariableDeclaration(Scope* scope, int pos)
       : VariableDeclaration(pos, true), scope_(scope) {}
@@ -405,25 +424,151 @@ class NestedVariableDeclaration final : public VariableDeclaration {
   Scope* scope_;
 };
 
-inline NestedVariableDeclaration* VariableDeclaration::AsNested() {
-  return IsNestedField::decode(bit_field_)
-             ? static_cast<NestedVariableDeclaration*>(this)
-             : nullptr;
-}
-
 class FunctionDeclaration final : public Declaration {
  public:
-  FunctionLiteral* fun() const { return fun_; }
+  template<typename T>
+  T* fun() { return static_cast<T*>(fun_); }
+
+  template<typename T>
+  const T* fun() const { return static_cast<const T*>(fun_); }
 
  private:
   friend class AstNodeFactory;
+  friend class BinAstNodeFactory;
 
-  FunctionDeclaration(FunctionLiteral* fun, int pos)
-      : Declaration(pos, kFunctionDeclaration), fun_(fun) {}
+  FunctionDeclaration(void* fun, int pos)
+      : Declaration(pos, Declaration::FunctionDecl), fun_(fun) {}
 
-  FunctionLiteral* fun_;
+  // This is a reference back to the FunctionLiteral AST node. This is a void* to avoid
+  // having to directly reference a particular AST type. Whoever consumes this needs to
+  // cast it themselves.
+  //
+  // The goal is to separate things so that the Scope hierarchy is indepedent of
+  // the AST types it's operating on. This is tricky with FunctionDeclarations since
+  // they need to refer back to their FunctionLiteral (an AST node) while the Scope
+  // maintains a list of Declarations.
+  void* fun_;
 };
 
+inline VariableDeclaration* Declaration::AsVariableDeclaration() {
+  return IsVariableDeclaration() ? static_cast<VariableDeclaration*>(this) : nullptr;
+}
+inline FunctionDeclaration* Declaration::AsFunctionDeclaration() {
+  return IsFunctionDeclaration() ? static_cast<FunctionDeclaration*>(this) : nullptr;
+}
+inline NestedVariableDeclaration* VariableDeclaration::AsNested() {
+  return is_nested() ? static_cast<NestedVariableDeclaration*>(this) : nullptr;
+}
+
+// class DeclarationNode : public AstNode {
+//  public:
+//   Declaration* declaration() { return decl_; }
+//   const Declaration* declaration() const { return decl_; }
+ 
+//   Variable* var() const { return declaration()->var(); }
+//   void set_var(Variable* var) { return declaration()->set_var(var); }
+
+//  protected:
+//   DeclarationNode(int pos, NodeType type, Declaration* decl) : AstNode(pos, type) {}
+
+//  private:
+//   Declaration* decl_;
+// };
+
+// class VariableDeclarationNode : public DeclarationNode {
+//  public:
+//   VariableDeclaration* var_decl() { return static_cast<VariableDeclaration*>(declaration()); }
+//   const VariableDeclaration* var_decl() const { return static_cast<const VariableDeclaration*>(declaration()); }
+
+//   bool is_nested() const { return var_decl()->is_nested(); }
+
+//  protected:
+//   explicit VariableDeclarationNode(VariableDeclaration* decl) : DeclarationNode(decl->position(), kVariableDeclarationNode, decl) {}
+
+//  private:
+//   friend class AstNodeFactory;
+// };
+
+// class NestedVariableDeclarationNode final : public VariableDeclarationNode {
+//  public:
+//   NestedVariableDeclaration* nested_var_decl() { return static_cast<NestedVariableDeclaration*>(declaration()); }
+//   const NestedVariableDeclaration* nested_var_decl() const { return static_cast<const NestedVariableDeclaration*>(declaration()); }
+
+//  private:
+//   friend class AstNodeFactory;
+
+//   NestedVariableDeclarationNode(NestedVariableDeclaration* decl) : VariableDeclarationNode(decl) {}
+// };
+
+// class FunctionDeclarationNode final : public DeclarationNode {
+//  public:
+//   FunctionLiteral* fun() const { return fun_; }
+
+//  private:
+//   friend class AstNodeFactory;
+
+//   FunctionDeclarationNode(FunctionLiteral* fun, int pos)
+//       : DeclarationNode(pos, kFunctionDeclarationNode, nullptr), fun_(fun) {}
+
+//   FunctionLiteral* fun_;
+// };
+
+
+// class VariableDeclaration : public Declaration {
+//  public:
+//   inline NestedVariableDeclaration* AsNested();
+
+//  private:
+//   friend class AstNodeFactory;
+
+//   using IsNestedField = Declaration::NextBitField<bool, 1>;
+
+//  protected:
+//   explicit VariableDeclaration(int pos, bool is_nested = false)
+//       : Declaration(pos, kVariableDeclaration) {
+//     bit_field_ = IsNestedField::update(bit_field_, is_nested);
+//   }
+
+//   template <class T, int size>
+//   using NextBitField = IsNestedField::Next<T, size>;
+// };
+
+// For var declarations that appear in a block scope.
+// Only distinguished from VariableDeclaration during Scope analysis,
+// so it doesn't get its own NodeType.
+// class NestedVariableDeclaration final : public VariableDeclaration {
+//  public:
+//   Scope* scope() const { return scope_; }
+
+//  private:
+//   friend class AstNodeFactory;
+
+//   NestedVariableDeclaration(Scope* scope, int pos)
+//       : VariableDeclaration(pos, true), scope_(scope) {}
+
+//   // Nested scope from which the declaration originated.
+//   Scope* scope_;
+// };
+
+// inline NestedVariableDeclaration* VariableDeclaration::AsNested() {
+//   return IsNestedField::decode(bit_field_)
+//              ? static_cast<NestedVariableDeclaration*>(this)
+//              : nullptr;
+// }
+
+// class FunctionDeclaration final : public Declaration {
+//  public:
+//   FunctionLiteral* fun() const { return fun_; }
+
+//  private:
+//   friend class AstNodeFactory;
+
+//   FunctionDeclaration(FunctionLiteral* fun, int pos)
+//       : Declaration(pos, kFunctionDeclaration), fun_(fun) {}
+
+//   FunctionLiteral* fun_;
+// };
+
 
 class IterationStatement : public BreakableStatement {
  public:
@@ -1390,7 +1535,7 @@ class ThisExpression final : public Expression {
   ThisExpression() : Expression(kNoSourcePosition, kThisExpression) {}
 };
 
-class VariableProxy final : public Expression {
+class VariableProxy final : public ZoneObject {
  public:
   bool IsValidReferenceExpression() const { return !is_new_target(); }
 
@@ -1409,6 +1554,8 @@ class VariableProxy final : public Expression {
     var_ = v;
   }
 
+  int position() const { return start_position_; }
+
   Scanner::Location location() {
     return Scanner::Location(position(), position() + raw_name()->length());
   }
@@ -1478,12 +1625,14 @@ class VariableProxy final : public Expression {
 
  private:
   friend class AstNodeFactory;
+  friend class BinAstNodeFactory;
 
   VariableProxy(Variable* var, int start_position);
 
   VariableProxy(const AstRawString* name, VariableKind variable_kind,
                 int start_position)
-      : Expression(start_position, kVariableProxy),
+      : start_position_(start_position),
+        bit_field_(0),
         raw_name_(name),
         next_unresolved_(nullptr) {
     DCHECK_NE(THIS_VARIABLE, variable_kind);
@@ -1495,7 +1644,10 @@ class VariableProxy final : public Expression {
 
   explicit VariableProxy(const VariableProxy* copy_from);
 
-  using IsAssignedField = Expression::NextBitField<bool, 1>;
+  int start_position_;
+  uint32_t bit_field_;
+
+  using IsAssignedField = base::BitField<bool, 0, 1>;
   using IsResolvedField = IsAssignedField::Next<bool, 1>;
   using IsRemovedFromUnresolvedField = IsResolvedField::Next<bool, 1>;
   using IsNewTargetField = IsRemovedFromUnresolvedField::Next<bool, 1>;
@@ -1526,6 +1678,53 @@ class OptionalChain final : public Expression {
   Expression* expression_;
 };
 
+
+class VariableProxyExpression final : public Expression {
+ public:
+  bool IsValidReferenceExpression() const { return !proxy_->is_new_target(); }
+
+  Handle<String> name() const { return proxy_->name(); }
+  const AstRawString* raw_name() const { return proxy_->raw_name(); }
+
+  Variable* var() const { return proxy_->var(); }
+  void set_var(Variable* v) { proxy_->set_var(v); }
+
+  Scanner::Location location() {
+    return Scanner::Location(position(), position() + raw_name()->length());
+  }
+
+  bool is_assigned() const { return proxy_->is_assigned(); }
+  void set_is_assigned() { proxy_->set_is_assigned(); }
+  void clear_is_assigned() { proxy_->clear_is_assigned(); }
+
+  bool is_resolved() const { return proxy_->is_resolved(); }
+  void set_is_resolved() { proxy_->set_is_resolved(); }
+
+  bool is_new_target() const { return proxy_->is_new_target(); }
+  void set_is_new_target() { proxy_->set_is_new_target(); }
+
+  HoleCheckMode hole_check_mode() const { return proxy_->hole_check_mode(); }
+  void set_needs_hole_check() { proxy_->set_needs_hole_check(); }
+
+  bool IsPrivateName() const { return proxy_->IsPrivateName(); }
+
+  // Bind this proxy to the variable var.
+  void BindTo(Variable* var);
+
+  void mark_removed_from_unresolved() { proxy_->mark_removed_from_unresolved(); }
+
+ private:
+  friend class AstNodeFactory;
+
+  VariableProxyExpression(VariableProxy* proxy)
+      : Expression(proxy->position(), kVariableProxyExpression),
+        proxy_(proxy) {
+  }
+
+  VariableProxy* proxy_;
+};
+
+
 // Assignments to a property will use one of several types of property access.
 // Otherwise, the assignment is to a non-property (a global, a local slot, a
 // parameter slot, or a destructuring pattern).
@@ -1560,7 +1759,7 @@ class Property final : public Expression {
     if (property == nullptr) return NON_PROPERTY;
     if (property->IsPrivateReference()) {
       DCHECK(!property->IsSuperAccess());
-      VariableProxy* proxy = property->key()->AsVariableProxy();
+      VariableProxyExpression* proxy = property->key()->AsVariableProxyExpression();
       DCHECK_NOT_NULL(proxy);
       Variable* var = proxy->var();
 
@@ -2490,15 +2689,15 @@ class SuperPropertyReference final : public Expression {
 
 class SuperCallReference final : public Expression {
  public:
-  VariableProxy* new_target_var() const { return new_target_var_; }
-  VariableProxy* this_function_var() const { return this_function_var_; }
+  VariableProxyExpression* new_target_var() const { return new_target_var_; }
+  VariableProxyExpression* this_function_var() const { return this_function_var_; }
 
  private:
   friend class AstNodeFactory;
 
   // We take in ThisExpression* only as a proof that it was accessed.
-  SuperCallReference(VariableProxy* new_target_var,
-                     VariableProxy* this_function_var, int pos)
+  SuperCallReference(VariableProxyExpression* new_target_var,
+                     VariableProxyExpression* this_function_var, int pos)
       : Expression(pos, kSuperCallReference),
         new_target_var_(new_target_var),
         this_function_var_(this_function_var) {
@@ -2506,8 +2705,8 @@ class SuperCallReference final : public Expression {
     DCHECK(this_function_var->raw_name()->IsOneByteEqualTo(".this_function"));
   }
 
-  VariableProxy* new_target_var_;
-  VariableProxy* this_function_var_;
+  VariableProxyExpression* new_target_var_;
+  VariableProxyExpression* this_function_var_;
 };
 
 // This AST Node is used to represent a dynamic import call --
@@ -2595,8 +2794,27 @@ class AstVisitor {
  public:
   void Visit(AstNode* node) { impl()->Visit(node); }
 
+  void VisitDeclaration(Declaration* decl) {
+    switch (decl->type()) {
+      case Declaration::VariableDecl: {
+        impl()->VisitVariableDeclaration(static_cast<VariableDeclaration*>(decl));
+        break;
+      }
+      case Declaration::FunctionDecl: {
+        impl()->VisitFunctionDeclaration(static_cast<FunctionDeclaration*>(decl));
+        break;
+      }
+      default: {
+        UNREACHABLE();
+      }
+    }
+  }
+
+  // void VisitDeclaration(VariableDeclaration* decl) {}
+  // void VisitDeclaration(FunctionDeclaration* decl) {}
+
   void VisitDeclarations(Declaration::List* declarations) {
-    for (Declaration* decl : *declarations) Visit(decl);
+    for (Declaration* decl : *declarations) VisitDeclaration(decl);
   }
 
   void VisitStatements(const ZonePtrList<Statement>* statements) {
@@ -2945,6 +3163,10 @@ class AstNodeFactory final {
     return new (zone_) ArrayLiteral(zone_, values, first_spread_index, pos);
   }
 
+  VariableProxyExpression* NewVariableProxyExpression(VariableProxy* proxy) {
+    return new (zone_) VariableProxyExpression(proxy);
+  }
+
   VariableProxy* NewVariableProxy(Variable* var,
                                   int start_position = kNoSourcePosition) {
     return new (zone_) VariableProxy(var, start_position);
@@ -3065,8 +3287,8 @@ class AstNodeFactory final {
     DCHECK_NOT_NULL(target);
     DCHECK_NOT_NULL(value);
 
-    if (op != Token::INIT && target->IsVariableProxy()) {
-      target->AsVariableProxy()->set_is_assigned();
+    if (op != Token::INIT && target->IsVariableProxyExpression()) {
+      target->AsVariableProxyExpression()->set_is_assigned();
     }
 
     if (op == Token::ASSIGN || op == Token::INIT) {
@@ -3165,8 +3387,8 @@ class AstNodeFactory final {
     return new (zone_) SuperPropertyReference(home_object, pos);
   }
 
-  SuperCallReference* NewSuperCallReference(VariableProxy* new_target_var,
-                                            VariableProxy* this_function_var,
+  SuperCallReference* NewSuperCallReference(VariableProxyExpression* new_target_var,
+                                            VariableProxyExpression* this_function_var,
                                             int pos) {
     return new (zone_)
         SuperCallReference(new_target_var, this_function_var, pos);
diff --git a/src/ast/prettyprinter.cc b/src/ast/prettyprinter.cc
index 20dca56cc4..544354dc5b 100644
--- a/src/ast/prettyprinter.cc
+++ b/src/ast/prettyprinter.cc
@@ -88,10 +88,10 @@ void CallPrinter::VisitBlock(Block* node) {
 }
 
 
-void CallPrinter::VisitVariableDeclaration(VariableDeclaration* node) {}
+void CallPrinter::VisitDeclaration(VariableDeclaration* decl) {}
 
 
-void CallPrinter::VisitFunctionDeclaration(FunctionDeclaration* node) {}
+void CallPrinter::VisitDeclaration(FunctionDeclaration* decl) {}
 
 
 void CallPrinter::VisitExpressionStatement(ExpressionStatement* node) {
@@ -293,7 +293,7 @@ void CallPrinter::VisitArrayLiteral(ArrayLiteral* node) {
 }
 
 
-void CallPrinter::VisitVariableProxy(VariableProxy* node) {
+void CallPrinter::VisitVariableProxyExpression(VariableProxyExpression* node) {
   if (is_user_js_) {
     PrintLiteral(node->name(), false);
   } else {
@@ -421,7 +421,7 @@ void CallPrinter::VisitCall(Call* node) {
   if (was_found) {
     // Bail out if the error is caused by a direct call to a variable in
     // non-user JS code. The variable name is meaningless due to minification.
-    if (!is_user_js_ && node->expression()->IsVariableProxy()) {
+    if (!is_user_js_ && node->expression()->IsVariableProxyExpression()) {
       done_ = true;
       return;
     }
@@ -456,7 +456,7 @@ void CallPrinter::VisitCallNew(CallNew* node) {
   if (was_found) {
     // Bail out if the error is caused by a direct call to a variable in
     // non-user JS code. The variable name is meaningless due to minification.
-    if (!is_user_js_ && node->expression()->IsVariableProxy()) {
+    if (!is_user_js_ && node->expression()->IsVariableProxyExpression()) {
       done_ = true;
       return;
     }
@@ -852,7 +852,21 @@ void AstPrinter::PrintOut(Isolate* isolate, AstNode* node) {
 void AstPrinter::PrintDeclarations(Declaration::List* declarations) {
   if (!declarations->is_empty()) {
     IndentedScope indent(this, "DECLS");
-    for (Declaration* decl : *declarations) Visit(decl);
+    for (Declaration* decl : *declarations) {
+      switch (decl->type()) {
+        case Declaration::VariableDecl: {
+          VisitDeclaration(static_cast<VariableDeclaration*>(decl));
+          break;
+        }
+        case Declaration::FunctionDecl: {
+          VisitDeclaration(static_cast<FunctionDeclaration*>(decl));
+          break;
+        }
+        default: {
+          UNREACHABLE();
+        }
+      }
+    }
   }
 }
 
@@ -888,18 +902,18 @@ void AstPrinter::VisitBlock(Block* node) {
 
 
 // TODO(svenpanne) Start with IndentedScope.
-void AstPrinter::VisitVariableDeclaration(VariableDeclaration* node) {
+void AstPrinter::VisitDeclaration(VariableDeclaration* node) {
   PrintLiteralWithModeIndented("VARIABLE", node->var(),
                                node->var()->raw_name());
 }
 
 
 // TODO(svenpanne) Start with IndentedScope.
-void AstPrinter::VisitFunctionDeclaration(FunctionDeclaration* node) {
+void AstPrinter::VisitDeclaration(FunctionDeclaration* node) {
   PrintIndented("FUNCTION ");
   PrintLiteral(node->var()->raw_name(), true);
   Print(" = function ");
-  PrintLiteral(node->fun()->raw_name(), false);
+  PrintLiteral(node->fun<FunctionLiteral>()->raw_name(), false);
   Print("\n");
 }
 
@@ -1226,7 +1240,7 @@ void AstPrinter::VisitArrayLiteral(ArrayLiteral* node) {
 }
 
 
-void AstPrinter::VisitVariableProxy(VariableProxy* node) {
+void AstPrinter::VisitVariableProxyExpression(VariableProxyExpression* node) {
   EmbeddedVector<char, 128> buf;
   int pos = SNPrintF(buf, "VAR PROXY");
 
diff --git a/src/ast/prettyprinter.h b/src/ast/prettyprinter.h
index 4b939c7d17..a64841a13e 100644
--- a/src/ast/prettyprinter.h
+++ b/src/ast/prettyprinter.h
@@ -50,6 +50,8 @@ class CallPrinter final : public AstVisitor<CallPrinter> {
 #define DECLARE_VISIT(type) void Visit##type(type* node);
   AST_NODE_LIST(DECLARE_VISIT)
 #undef DECLARE_VISIT
+  void VisitDeclaration(VariableDeclaration* decl);
+  void VisitDeclaration(FunctionDeclaration* decl);
 
  private:
   void Print(const char* str);
@@ -104,6 +106,8 @@ class AstPrinter final : public AstVisitor<AstPrinter> {
 #define DECLARE_VISIT(type) void Visit##type(type* node);
   AST_NODE_LIST(DECLARE_VISIT)
 #undef DECLARE_VISIT
+  void VisitDeclaration(VariableDeclaration* decl);
+  void VisitDeclaration(FunctionDeclaration* decl);
 
  private:
   friend class IndentedScope;
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
index 3f0a1adbc3..a42d8dc114 100644
--- a/src/ast/scopes.cc
+++ b/src/ast/scopes.cc
@@ -114,6 +114,11 @@ Scope::Scope(Zone* zone, Scope* outer_scope, ScopeType scope_type)
 DeclarationScope::DeclarationScope(Zone* zone,
                                    AstValueFactory* ast_value_factory,
                                    REPLMode repl_mode)
+    : DeclarationScope(zone, ast_value_factory->this_string(), repl_mode) {}
+
+DeclarationScope::DeclarationScope(Zone* zone,
+                                   const AstRawString* this_string,
+                                   REPLMode repl_mode)
     : Scope(zone),
       function_kind_(repl_mode == REPLMode::kYes ? kAsyncFunction
                                                  : kNormalFunction),
@@ -121,7 +126,7 @@ DeclarationScope::DeclarationScope(Zone* zone,
   DCHECK_EQ(scope_type_, SCRIPT_SCOPE);
   SetDefaults();
   is_repl_mode_scope_ = repl_mode == REPLMode::kYes;
-  receiver_ = DeclareDynamicGlobal(ast_value_factory->this_string(),
+  receiver_ = DeclareDynamicGlobal(this_string,
                                    THIS_VARIABLE, this);
 }
 
@@ -141,7 +146,7 @@ ModuleScope::ModuleScope(DeclarationScope* script_scope,
       module_descriptor_(new (avfactory->zone())
                              SourceTextModuleDescriptor(avfactory->zone())) {
   set_language_mode(LanguageMode::kStrict);
-  DeclareThis(avfactory);
+  DeclareThis(avfactory->this_string());
 }
 
 ModuleScope::ModuleScope(Isolate* isolate, Handle<ScopeInfo> scope_info,
@@ -549,8 +554,10 @@ void DeclarationScope::HoistSloppyBlockFunctions(AstNodeFactory* factory) {
       VariableProxy* source =
           factory->NewVariableProxy(sloppy_block_function->var());
       VariableProxy* target = factory->NewVariableProxy(var);
+      VariableProxyExpression* source_expr = factory->NewVariableProxyExpression(source);
+      VariableProxyExpression* target_expr = factory->NewVariableProxyExpression(target);
       Assignment* assignment = factory->NewAssignment(
-          sloppy_block_function->init(), target, source, pos);
+          sloppy_block_function->init(), target_expr, source_expr, pos);
       assignment->set_lookup_hoisting_mode(LookupHoistingMode::kLegacySloppy);
       Statement* statement = factory->NewExpressionStatement(assignment, pos);
       sloppy_block_function->set_statement(statement);
@@ -616,20 +623,20 @@ bool DeclarationScope::Analyze(ParseInfo* info) {
   return true;
 }
 
-void DeclarationScope::DeclareThis(AstValueFactory* ast_value_factory) {
+void DeclarationScope::DeclareThis(const AstRawString* this_string) {
   DCHECK(has_this_declaration());
 
   bool derived_constructor = IsDerivedConstructor(function_kind_);
 
   receiver_ = new (zone())
-      Variable(this, ast_value_factory->this_string(),
+      Variable(this, this_string,
                derived_constructor ? VariableMode::kConst : VariableMode::kVar,
                THIS_VARIABLE,
                derived_constructor ? kNeedsInitialization : kCreatedInitialized,
                kNotAssigned);
 }
 
-void DeclarationScope::DeclareArguments(AstValueFactory* ast_value_factory) {
+void DeclarationScope::DeclareArguments(const AstRawString* arguments_string) {
   DCHECK(is_function_scope());
   DCHECK(!is_arrow_scope());
 
@@ -638,7 +645,7 @@ void DeclarationScope::DeclareArguments(AstValueFactory* ast_value_factory) {
   // variable allocation.
   bool was_added;
   arguments_ =
-      Declare(zone(), ast_value_factory->arguments_string(), VariableMode::kVar,
+      Declare(zone(), arguments_string, VariableMode::kVar,
               NORMAL_VARIABLE, kCreatedInitialized, kNotAssigned, &was_added);
   if (!was_added && IsLexicalVariableMode(arguments_->mode())) {
     // Check if there's lexically declared variable named arguments to avoid
@@ -648,13 +655,15 @@ void DeclarationScope::DeclareArguments(AstValueFactory* ast_value_factory) {
 }
 
 void DeclarationScope::DeclareDefaultFunctionVariables(
-    AstValueFactory* ast_value_factory) {
+    const AstRawString* this_string,
+    const AstRawString* new_target_string,
+    const AstRawString* this_function_string) {
   DCHECK(is_function_scope());
   DCHECK(!is_arrow_scope());
 
-  DeclareThis(ast_value_factory);
+  DeclareThis(this_string);
   bool was_added;
-  new_target_ = Declare(zone(), ast_value_factory->new_target_string(),
+  new_target_ = Declare(zone(), new_target_string,
                         VariableMode::kConst, NORMAL_VARIABLE,
                         kCreatedInitialized, kNotAssigned, &was_added);
   DCHECK(was_added);
@@ -662,7 +671,7 @@ void DeclarationScope::DeclareDefaultFunctionVariables(
   if (IsConciseMethod(function_kind_) || IsClassConstructor(function_kind_) ||
       IsAccessorFunction(function_kind_)) {
     EnsureRareData()->this_function = Declare(
-        zone(), ast_value_factory->this_function_string(), VariableMode::kConst,
+        zone(), this_function_string, VariableMode::kConst,
         NORMAL_VARIABLE, kCreatedInitialized, kNotAssigned, &was_added);
     DCHECK(was_added);
   }
@@ -891,7 +900,7 @@ Variable* Scope::LookupInScopeInfo(const AstRawString* name, Scope* cache) {
 Variable* DeclarationScope::DeclareParameter(const AstRawString* name,
                                              VariableMode mode,
                                              bool is_optional, bool is_rest,
-                                             AstValueFactory* ast_value_factory,
+                                             const AstRawString* arguments_string,
                                              int position) {
   DCHECK(!already_resolved_);
   DCHECK(is_function_scope() || is_module_scope());
@@ -911,7 +920,7 @@ Variable* DeclarationScope::DeclareParameter(const AstRawString* name,
   var->set_initializer_position(position);
   params_.Add(var, zone());
   if (!is_rest) ++num_parameters_;
-  if (name == ast_value_factory->arguments_string()) {
+  if (name == arguments_string) {
     has_arguments_parameter_ = true;
   }
   // Params are automatically marked as used to make sure that the debugger and
@@ -1220,7 +1229,7 @@ void DeclarationScope::DeserializeReceiver(AstValueFactory* ast_value_factory) {
     return;
   }
   DCHECK(has_this_declaration());
-  DeclareThis(ast_value_factory);
+  DeclareThis(ast_value_factory->this_string());
   if (is_debug_evaluate_scope()) {
     receiver_->AllocateTo(VariableLocation::LOOKUP, -1);
   } else {
@@ -1533,7 +1542,7 @@ void DeclarationScope::ResetAfterPreparsing(AstValueFactory* ast_value_factory,
     variables_.Reset(ZoneAllocationPolicy(zone_));
     if (!IsArrowFunction(function_kind_)) {
       has_simple_parameters_ = true;
-      DeclareDefaultFunctionVariables(ast_value_factory);
+      DeclareDefaultFunctionVariables(ast_value_factory->this_string(), ast_value_factory->new_target_string(), ast_value_factory->this_function_string());
     }
   } else {
     // Make sure this scope isn't used for allocation anymore.
@@ -2806,23 +2815,23 @@ VariableProxy* ClassScope::ResolvePrivateNamesPartially() {
   return nullptr;
 }
 
-Variable* ClassScope::DeclareBrandVariable(AstValueFactory* ast_value_factory,
-                                           IsStaticFlag is_static_flag,
-                                           int class_token_pos) {
-  DCHECK_IMPLIES(GetRareData() != nullptr, GetRareData()->brand == nullptr);
-  bool was_added;
-  Variable* brand = Declare(zone(), ast_value_factory->dot_brand_string(),
-                            VariableMode::kConst, NORMAL_VARIABLE,
-                            InitializationFlag::kNeedsInitialization,
-                            MaybeAssignedFlag::kNotAssigned, &was_added);
-  DCHECK(was_added);
-  brand->set_is_static_flag(is_static_flag);
-  brand->ForceContextAllocation();
-  brand->set_is_used();
-  EnsureRareData()->brand = brand;
-  brand->set_initializer_position(class_token_pos);
-  return brand;
-}
+// Variable* ClassScope::DeclareBrandVariable(AstValueFactory* ast_value_factory,
+//                                            IsStaticFlag is_static_flag,
+//                                            int class_token_pos) {
+//   DCHECK_IMPLIES(GetRareData() != nullptr, GetRareData()->brand == nullptr);
+//   bool was_added;
+//   Variable* brand = Declare(zone(), ast_value_factory->dot_brand_string(),
+//                             VariableMode::kConst, NORMAL_VARIABLE,
+//                             InitializationFlag::kNeedsInitialization,
+//                             MaybeAssignedFlag::kNotAssigned, &was_added);
+//   DCHECK(was_added);
+//   brand->set_is_static_flag(is_static_flag);
+//   brand->ForceContextAllocation();
+//   brand->set_is_used();
+//   EnsureRareData()->brand = brand;
+//   brand->set_initializer_position(class_token_pos);
+//   return brand;
+// }
 
 Variable* ClassScope::DeclareClassVariable(AstValueFactory* ast_value_factory,
                                            const AstRawString* name,
diff --git a/src/ast/scopes.h b/src/ast/scopes.h
index babb90bdd0..91ab2a8962 100644
--- a/src/ast/scopes.h
+++ b/src/ast/scopes.h
@@ -809,6 +809,8 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {
   // Creates a script scope.
   DeclarationScope(Zone* zone, AstValueFactory* ast_value_factory,
                    REPLMode repl_mode = REPLMode::kNo);
+  DeclarationScope(Zone* zone, const AstRawString* this_string,
+                   REPLMode repl_mode = REPLMode::kNo);
 
   FunctionKind function_kind() const { return function_kind_; }
 
@@ -941,10 +943,12 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {
     function_kind_ = kAsyncModule;
   }
 
-  void DeclareThis(AstValueFactory* ast_value_factory);
-  void DeclareArguments(AstValueFactory* ast_value_factory);
-  void DeclareDefaultFunctionVariables(AstValueFactory* ast_value_factory);
-
+  void DeclareThis(const AstRawString* this_string);
+  void DeclareArguments(const AstRawString* arguments_string);
+  void DeclareDefaultFunctionVariables(
+    const AstRawString* this_string,
+    const AstRawString* new_target_string,
+    const AstRawString* this_function_string);
   // Declare the function variable for a function literal. This variable
   // is in an intermediate scope between this function scope and the the
   // outer scope. Only possible for function scopes; at most one variable.
@@ -965,7 +969,7 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {
   // expects all parameters to be declared and from left to right.
   Variable* DeclareParameter(const AstRawString* name, VariableMode mode,
                              bool is_optional, bool is_rest,
-                             AstValueFactory* ast_value_factory, int position);
+                             const AstRawString* arguments_string, int position);
 
   // Makes sure that num_parameters_ and has_rest is correct for the preparser.
   void RecordParameter(bool is_rest);
@@ -1369,9 +1373,25 @@ class V8_EXPORT_PRIVATE ClassScope : public Scope {
   // and the current tail.
   void MigrateUnresolvedPrivateNameTail(AstNodeFactory* ast_node_factory,
                                         UnresolvedList::Iterator tail);
-  Variable* DeclareBrandVariable(AstValueFactory* ast_value_factory,
+
+  Variable* DeclareBrandVariable(const AstRawString* dot_brand_string,
                                  IsStaticFlag is_static_flag,
-                                 int class_token_pos);
+                                 int class_token_pos)
+  {
+    DCHECK_IMPLIES(GetRareData() != nullptr, GetRareData()->brand == nullptr);
+    bool was_added;
+    Variable* brand = Declare(zone(), dot_brand_string,
+                              VariableMode::kConst, NORMAL_VARIABLE,
+                              InitializationFlag::kNeedsInitialization,
+                              MaybeAssignedFlag::kNotAssigned, &was_added);
+    DCHECK(was_added);
+    brand->set_is_static_flag(is_static_flag);
+    brand->ForceContextAllocation();
+    brand->set_is_used();
+    EnsureRareData()->brand = brand;
+    brand->set_initializer_position(class_token_pos);
+    return brand;
+  }
 
   Variable* DeclareClassVariable(AstValueFactory* ast_value_factory,
                                  const AstRawString* name, int class_token_pos);
diff --git a/src/ast/source-range-ast-visitor.cc b/src/ast/source-range-ast-visitor.cc
index 52359d5452..4b64c79ce3 100644
--- a/src/ast/source-range-ast-visitor.cc
+++ b/src/ast/source-range-ast-visitor.cc
@@ -71,6 +71,16 @@ bool SourceRangeAstVisitor::VisitNode(AstNode* node) {
   return true;
 }
 
+bool SourceRangeAstVisitor::VisitDeclaration(VariableDeclaration* decl) {
+  // TODO(binast): I don't think we need to worry about source map ranges for declarations (at least according to what gets inserted into the map by the parser).
+  return true;
+}
+
+bool SourceRangeAstVisitor::VisitDeclaration(FunctionDeclaration* decl) {
+  // TODO(binast): I don't think we need to worry about source map ranges for declarations (at least according to what gets inserted into the map by the parser).
+  return true;
+}
+
 void SourceRangeAstVisitor::MaybeRemoveContinuationRange(
     Statement* last_statement) {
   AstNodeSourceRanges* last_range = nullptr;
diff --git a/src/ast/source-range-ast-visitor.h b/src/ast/source-range-ast-visitor.h
index 42f69e8b20..041686e7b2 100644
--- a/src/ast/source-range-ast-visitor.h
+++ b/src/ast/source-range-ast-visitor.h
@@ -39,6 +39,8 @@ class SourceRangeAstVisitor final
   bool VisitNode(AstNode* node);
   void VisitTryCatchStatement(TryCatchStatement* stmt);
   void VisitTryFinallyStatement(TryFinallyStatement* stmt);
+  bool VisitDeclaration(VariableDeclaration* decl);
+  bool VisitDeclaration(FunctionDeclaration* decl);
 
   void MaybeRemoveContinuationRange(Statement* last_statement);
   void MaybeRemoveLastContinuationRange(ZonePtrList<Statement>* stmts);
diff --git a/src/debug/liveedit.cc b/src/debug/liveedit.cc
index c5f858f63d..31e0b6bdde 100644
--- a/src/debug/liveedit.cc
+++ b/src/debug/liveedit.cc
@@ -737,6 +737,8 @@ class CollectFunctionLiterals final
     AstTraversalVisitor::VisitFunctionLiteral(lit);
     literals_->push_back(lit);
   }
+  void VisitDeclaration(VariableDeclaration* decl) {}
+  void VisitDeclaration(FunctionDeclaration* decl) {}
   void Run(std::vector<FunctionLiteral*>* literals) {
     literals_ = literals;
     AstTraversalVisitor::Run();
diff --git a/src/interpreter/bytecode-generator.cc b/src/interpreter/bytecode-generator.cc
index 9a75837063..ffc7f30644 100644
--- a/src/interpreter/bytecode-generator.cc
+++ b/src/interpreter/bytecode-generator.cc
@@ -746,7 +746,7 @@ class BytecodeGenerator::TopLevelDeclarationsBuilder final : public ZoneObject {
         int start = array_index;
 #endif
         if (decl->IsFunctionDeclaration()) {
-          FunctionLiteral* f = static_cast<FunctionDeclaration*>(decl)->fun();
+          FunctionLiteral* f = static_cast<FunctionDeclaration*>(decl)->fun<FunctionLiteral>();
           Handle<SharedFunctionInfo> sfi(
               Compiler::GetSharedFunctionInfo(f, script, isolate));
           // Return a null handle if any initial values can't be created. Caller
@@ -775,7 +775,7 @@ class BytecodeGenerator::TopLevelDeclarationsBuilder final : public ZoneObject {
           data->set(array_index++, *var->raw_name()->string());
           DCHECK_EQ(start + kGlobalVariableDeclarationSize, array_index);
         } else {
-          FunctionLiteral* f = static_cast<FunctionDeclaration*>(decl)->fun();
+          FunctionLiteral* f = static_cast<FunctionDeclaration*>(decl)->fun<FunctionLiteral>();
           Handle<SharedFunctionInfo> sfi(
               Compiler::GetSharedFunctionInfo(f, script, isolate));
           // Return a null handle if any initial values can't be created. Caller
@@ -1500,14 +1500,14 @@ void BytecodeGenerator::VisitFunctionDeclaration(FunctionDeclaration* decl) {
       UNREACHABLE();
     case VariableLocation::PARAMETER:
     case VariableLocation::LOCAL: {
-      VisitFunctionLiteral(decl->fun());
+      VisitFunctionLiteral(decl->fun<FunctionLiteral>());
       BuildVariableAssignment(variable, Token::INIT, HoleCheckMode::kElided);
       break;
     }
     case VariableLocation::REPL_GLOBAL:
     case VariableLocation::CONTEXT: {
       DCHECK_EQ(0, execution_context()->ContextChainDepth(variable->scope()));
-      VisitFunctionLiteral(decl->fun());
+      VisitFunctionLiteral(decl->fun<FunctionLiteral>());
       builder()->StoreContextSlot(execution_context()->reg(), variable->index(),
                                   0);
       break;
@@ -1517,15 +1517,15 @@ void BytecodeGenerator::VisitFunctionDeclaration(FunctionDeclaration* decl) {
       builder()
           ->LoadLiteral(variable->raw_name())
           .StoreAccumulatorInRegister(args[0]);
-      VisitFunctionLiteral(decl->fun());
+      VisitFunctionLiteral(decl->fun<FunctionLiteral>());
       builder()->StoreAccumulatorInRegister(args[1]).CallRuntime(
           Runtime::kDeclareEvalFunction, args);
       break;
     }
   }
   DCHECK_IMPLIES(
-      eager_inner_literals_ != nullptr && decl->fun()->ShouldEagerCompile(),
-      IsInEagerLiterals(decl->fun(), *eager_inner_literals_));
+      eager_inner_literals_ != nullptr && decl->fun<FunctionLiteral>()->ShouldEagerCompile(),
+      IsInEagerLiterals(decl->fun<FunctionLiteral>(), *eager_inner_literals_));
 }
 
 void BytecodeGenerator::VisitModuleNamespaceImports() {
@@ -1573,7 +1573,7 @@ void BytecodeGenerator::VisitModuleDeclarations(Declaration::List* decls) {
       if (decl->IsFunctionDeclaration()) {
         DCHECK(var->IsExport());
         FunctionDeclaration* f = static_cast<FunctionDeclaration*>(decl);
-        AddToEagerLiteralsIfEager(f->fun());
+        AddToEagerLiteralsIfEager(f->fun<FunctionLiteral>());
         top_level_builder()->record_module_function_declaration();
       } else if (var->IsExport() && var->binding_needs_init()) {
         DCHECK(decl->IsVariableDeclaration());
@@ -1581,7 +1581,7 @@ void BytecodeGenerator::VisitModuleDeclarations(Declaration::List* decls) {
       }
     } else {
       RegisterAllocationScope register_scope(this);
-      Visit(decl);
+      VisitDeclaration(decl);
     }
   }
   BuildDeclareCall(Runtime::kDeclareModuleExports);
@@ -1597,7 +1597,7 @@ void BytecodeGenerator::VisitGlobalDeclarations(Declaration::List* decls) {
       if (decl->IsFunctionDeclaration()) {
         top_level_builder()->record_global_function_declaration();
         FunctionDeclaration* f = static_cast<FunctionDeclaration*>(decl);
-        AddToEagerLiteralsIfEager(f->fun());
+        AddToEagerLiteralsIfEager(f->fun<FunctionLiteral>());
       } else {
         top_level_builder()->record_global_variable_declaration();
       }
@@ -1614,7 +1614,7 @@ void BytecodeGenerator::VisitGlobalDeclarations(Declaration::List* decls) {
 void BytecodeGenerator::VisitDeclarations(Declaration::List* declarations) {
   for (Declaration* decl : *declarations) {
     RegisterAllocationScope register_scope(this);
-    Visit(decl);
+    VisitDeclaration(decl);
   }
 }
 
@@ -2475,7 +2475,7 @@ void BytecodeGenerator::VisitInitializeClassMembersStatement(
 void BytecodeGenerator::BuildInvalidPropertyAccess(MessageTemplate tmpl,
                                                    Property* property) {
   RegisterAllocationScope register_scope(this);
-  const AstRawString* name = property->key()->AsVariableProxy()->raw_name();
+  const AstRawString* name = property->key()->AsVariableProxyExpression()->raw_name();
   RegisterList args = register_allocator()->NewRegisterList(2);
   builder()
       ->LoadLiteral(Smi::FromEnum(tmpl))
@@ -3065,7 +3065,7 @@ void BytecodeGenerator::VisitArrayLiteral(ArrayLiteral* expr) {
   BuildCreateArrayLiteral(expr->values(), expr);
 }
 
-void BytecodeGenerator::VisitVariableProxy(VariableProxy* proxy) {
+void BytecodeGenerator::VisitVariableProxyExpression(VariableProxyExpression* proxy) {
   builder()->SetExpressionPosition(proxy);
   BuildVariableLoad(proxy->var(), proxy->hole_check_mode());
 }
@@ -4002,8 +4002,8 @@ void BytecodeGenerator::BuildAssignment(
         // Split object literals into destructuring.
         BuildDestructuringArrayAssignment(pattern, op, lookup_hoisting_mode);
       } else {
-        DCHECK(lhs_data.expr()->IsVariableProxy());
-        VariableProxy* proxy = lhs_data.expr()->AsVariableProxy();
+        DCHECK(lhs_data.expr()->IsVariableProxyExpression());
+        VariableProxyExpression* proxy = lhs_data.expr()->AsVariableProxyExpression();
         BuildVariableAssignment(proxy->var(), op, proxy->hole_check_mode(),
                                 lookup_hoisting_mode);
       }
@@ -4085,7 +4085,7 @@ void BytecodeGenerator::VisitCompoundAssignment(CompoundAssignment* expr) {
   // the left-hand side value and performing a binary operation.
   switch (lhs_data.assign_type()) {
     case NON_PROPERTY: {
-      VariableProxy* proxy = expr->target()->AsVariableProxy();
+      VariableProxyExpression* proxy = expr->target()->AsVariableProxyExpression();
       BuildVariableLoad(proxy->var(), proxy->hole_check_mode());
       break;
     }
@@ -4661,7 +4661,7 @@ void BytecodeGenerator::BuildPrivateSetterAccess(Register object,
 void BytecodeGenerator::BuildPrivateBrandCheck(Property* property,
                                                Register object,
                                                MessageTemplate tmpl) {
-  Variable* private_name = property->key()->AsVariableProxy()->var();
+  Variable* private_name = property->key()->AsVariableProxyExpression()->var();
   DCHECK(IsPrivateMethodOrAccessorVariableMode(private_name->mode()));
   ClassScope* scope = private_name->scope()->AsClassScope();
   if (private_name->is_static()) {
@@ -4833,7 +4833,7 @@ void BytecodeGenerator::VisitCall(Call* expr) {
         BuildPushUndefinedIntoRegisterList(&args);
       }
       // Load callee as a global variable.
-      VariableProxy* proxy = callee_expr->AsVariableProxy();
+      VariableProxyExpression* proxy = callee_expr->AsVariableProxyExpression();
       BuildVariableLoadForAccumulatorValue(proxy->var(),
                                            proxy->hole_check_mode());
       builder()->StoreAccumulatorInRegister(callee);
@@ -4841,14 +4841,14 @@ void BytecodeGenerator::VisitCall(Call* expr) {
     }
     case Call::WITH_CALL: {
       Register receiver = register_allocator()->GrowRegisterList(&args);
-      DCHECK(callee_expr->AsVariableProxy()->var()->IsLookupSlot());
+      DCHECK(callee_expr->AsVariableProxyExpression()->var()->IsLookupSlot());
       {
         RegisterAllocationScope inner_register_scope(this);
         Register name = register_allocator()->NewRegister();
 
         // Call %LoadLookupSlotForCall to get the callee and receiver.
         RegisterList result_pair = register_allocator()->NewRegisterList(2);
-        Variable* variable = callee_expr->AsVariableProxy()->var();
+        Variable* variable = callee_expr->AsVariableProxyExpression()->var();
         builder()
             ->LoadLiteral(variable->raw_name())
             .StoreAccumulatorInRegister(name)
@@ -5095,10 +5095,10 @@ void BytecodeGenerator::VisitVoid(UnaryOperation* expr) {
 }
 
 void BytecodeGenerator::VisitForTypeOfValue(Expression* expr) {
-  if (expr->IsVariableProxy()) {
+  if (expr->IsVariableProxyExpression()) {
     // Typeof does not throw a reference error on global variables, hence we
     // perform a non-contextual load in case the operand is a variable proxy.
-    VariableProxy* proxy = expr->AsVariableProxy();
+    VariableProxyExpression* proxy = expr->AsVariableProxyExpression();
     BuildVariableLoadForAccumulatorValue(proxy->var(), proxy->hole_check_mode(),
                                          INSIDE_TYPEOF);
   } else {
@@ -5189,12 +5189,12 @@ void BytecodeGenerator::VisitDelete(UnaryOperation* unary) {
       VisitForEffect(expr);
       builder()->LoadTrue();
     }
-  } else if (expr->IsVariableProxy() &&
-             !expr->AsVariableProxy()->is_new_target()) {
+  } else if (expr->IsVariableProxyExpression() &&
+             !expr->AsVariableProxyExpression()->is_new_target()) {
     // Delete of an unqualified identifier is allowed in sloppy mode but is
     // not allowed in strict mode.
     DCHECK(is_sloppy(language_mode()));
-    Variable* variable = expr->AsVariableProxy()->var();
+    Variable* variable = expr->AsVariableProxyExpression()->var();
     switch (variable->location()) {
       case VariableLocation::PARAMETER:
       case VariableLocation::LOCAL:
@@ -5247,7 +5247,7 @@ void BytecodeGenerator::VisitCountOperation(CountOperation* expr) {
   const AstRawString* name;
   switch (assign_type) {
     case NON_PROPERTY: {
-      VariableProxy* proxy = expr->expression()->AsVariableProxy();
+      VariableProxyExpression* proxy = expr->expression()->AsVariableProxyExpression();
       BuildVariableLoadForAccumulatorValue(proxy->var(),
                                            proxy->hole_check_mode());
       break;
@@ -5340,7 +5340,7 @@ void BytecodeGenerator::VisitCountOperation(CountOperation* expr) {
   builder()->SetExpressionPosition(expr);
   switch (assign_type) {
     case NON_PROPERTY: {
-      VariableProxy* proxy = expr->expression()->AsVariableProxy();
+      VariableProxyExpression* proxy = expr->expression()->AsVariableProxyExpression();
       BuildVariableAssignment(proxy->var(), expr->op(),
                               proxy->hole_check_mode());
       break;
@@ -6558,10 +6558,10 @@ FeedbackSlot BytecodeGenerator::GetCachedLoadICSlot(const Expression* expr,
   }
   FeedbackSlotCache::SlotKind slot_kind =
       FeedbackSlotCache::SlotKind::kLoadProperty;
-  if (!expr->IsVariableProxy()) {
+  if (!expr->IsVariableProxyExpression()) {
     return feedback_spec()->AddLoadICSlot();
   }
-  const VariableProxy* proxy = expr->AsVariableProxy();
+  const VariableProxyExpression* proxy = expr->AsVariableProxyExpression();
   FeedbackSlot slot(
       feedback_slot_cache()->Get(slot_kind, proxy->var()->index(), name));
   if (!slot.IsInvalid()) {
@@ -6582,10 +6582,10 @@ FeedbackSlot BytecodeGenerator::GetCachedStoreICSlot(const Expression* expr,
       is_strict(language_mode())
           ? FeedbackSlotCache::SlotKind::kStoreNamedStrict
           : FeedbackSlotCache::SlotKind::kStoreNamedSloppy;
-  if (!expr->IsVariableProxy()) {
+  if (!expr->IsVariableProxyExpression()) {
     return feedback_spec()->AddStoreICSlot(language_mode());
   }
-  const VariableProxy* proxy = expr->AsVariableProxy();
+  const VariableProxyExpression* proxy = expr->AsVariableProxyExpression();
   FeedbackSlot slot(
       feedback_slot_cache()->Get(slot_kind, proxy->var()->index(), name));
   if (!slot.IsInvalid()) {
diff --git a/src/interpreter/bytecode-generator.h b/src/interpreter/bytecode-generator.h
index 2b11e721fa..652d894a2b 100644
--- a/src/interpreter/bytecode-generator.h
+++ b/src/interpreter/bytecode-generator.h
@@ -56,6 +56,8 @@ class BytecodeGenerator final : public AstVisitor<BytecodeGenerator> {
   void VisitGlobalDeclarations(Declaration::List* declarations);
   void VisitDeclarations(Declaration::List* declarations);
   void VisitStatements(const ZonePtrList<Statement>* statments);
+  void VisitVariableDeclaration(VariableDeclaration* decl);
+  void VisitFunctionDeclaration(FunctionDeclaration* decl);
 
  private:
   class AccumulatorPreservingScope;
diff --git a/src/parsing/func-name-inferrer.cc b/src/parsing/func-name-inferrer.cc
index b61224fbbb..20136fc690 100644
--- a/src/parsing/func-name-inferrer.cc
+++ b/src/parsing/func-name-inferrer.cc
@@ -11,71 +11,6 @@
 namespace v8 {
 namespace internal {
 
-FuncNameInferrer::FuncNameInferrer(AstValueFactory* ast_value_factory)
-    : ast_value_factory_(ast_value_factory) {}
-
-void FuncNameInferrer::PushEnclosingName(const AstRawString* name) {
-  // Enclosing name is a name of a constructor function. To check
-  // that it is really a constructor, we check that it is not empty
-  // and starts with a capital letter.
-  if (!name->IsEmpty() && unibrow::Uppercase::Is(name->FirstCharacter())) {
-    names_stack_.push_back(Name(name, kEnclosingConstructorName));
-  }
-}
-
-
-void FuncNameInferrer::PushLiteralName(const AstRawString* name) {
-  if (IsOpen() && name != ast_value_factory_->prototype_string()) {
-    names_stack_.push_back(Name(name, kLiteralName));
-  }
-}
-
-
-void FuncNameInferrer::PushVariableName(const AstRawString* name) {
-  if (IsOpen() && name != ast_value_factory_->dot_result_string()) {
-    names_stack_.push_back(Name(name, kVariableName));
-  }
-}
-
-void FuncNameInferrer::RemoveAsyncKeywordFromEnd() {
-  if (IsOpen()) {
-    CHECK_GT(names_stack_.size(), 0);
-    CHECK(names_stack_.back().name()->IsOneByteEqualTo("async"));
-    names_stack_.pop_back();
-  }
-}
-
-AstConsString* FuncNameInferrer::MakeNameFromStack() {
-  if (names_stack_.size() == 0) {
-    return ast_value_factory_->empty_cons_string();
-  }
-  AstConsString* result = ast_value_factory_->NewConsString();
-  auto it = names_stack_.begin();
-  while (it != names_stack_.end()) {
-    // Advance the iterator to be able to peek the next value.
-    auto current = it++;
-    // Skip consecutive variable declarations.
-    if (it != names_stack_.end() && current->type() == kVariableName &&
-        it->type() == kVariableName) {
-      continue;
-    }
-    // Add name. Separate names with ".".
-    Zone* zone = ast_value_factory_->zone();
-    if (!result->IsEmpty()) {
-      result->AddString(zone, ast_value_factory_->dot_string());
-    }
-    result->AddString(zone, current->name());
-  }
-  return result;
-}
-
-void FuncNameInferrer::InferFunctionsNames() {
-  AstConsString* func_name = MakeNameFromStack();
-  for (FunctionLiteral* func : funcs_to_infer_) {
-    func->set_raw_inferred_name(func_name);
-  }
-  funcs_to_infer_.resize(0);
-}
 
 
 }  // namespace internal
diff --git a/src/parsing/func-name-inferrer.h b/src/parsing/func-name-inferrer.h
index 553e6fa512..4dd2292351 100644
--- a/src/parsing/func-name-inferrer.h
+++ b/src/parsing/func-name-inferrer.h
@@ -9,6 +9,7 @@
 
 #include "src/base/macros.h"
 #include "src/utils/pointer-with-payload.h"
+#include "src/ast/ast-value-factory.h"
 
 namespace v8 {
 namespace internal {
@@ -35,9 +36,14 @@ struct PointerWithPayloadTraits<AstRawString> {
 // and during parsing of the RHS, a function literal can be collected. After
 // parsing the RHS we can infer a name for function literals that do not have
 // a name.
+template <typename Types>
 class FuncNameInferrer {
  public:
-  explicit FuncNameInferrer(AstValueFactory* ast_value_factory);
+  using AstValueFactory = typename Types::AstValueFactory;
+  using FunctionLiteral = typename Types::FunctionLiteral;
+
+  explicit FuncNameInferrer(AstValueFactory* ast_value_factory)
+    : ast_value_factory_(ast_value_factory) {}
 
   // To enter function name inference state, put a FuncNameInferrer::State
   // on the stack.
@@ -64,15 +70,30 @@ class FuncNameInferrer {
   bool IsOpen() const { return scope_depth_ > 0; }
 
   // Pushes an enclosing the name of enclosing function onto names stack.
-  void PushEnclosingName(const AstRawString* name);
+  void PushEnclosingName(const AstRawString* name) {
+    // Enclosing name is a name of a constructor function. To check
+    // that it is really a constructor, we check that it is not empty
+    // and starts with a capital letter.
+    if (!name->IsEmpty() && unibrow::Uppercase::Is(name->FirstCharacter())) {
+      names_stack_.push_back(Name(name, kEnclosingConstructorName));
+    }
+  }
 
   // Pushes an encountered name onto names stack when in collection state.
-  void PushLiteralName(const AstRawString* name);
+  void PushLiteralName(const AstRawString* name) {
+    if (IsOpen() && name != ast_value_factory_->prototype_string()) {
+      names_stack_.push_back(Name(name, kLiteralName));
+    }
+  }
 
-  void PushVariableName(const AstRawString* name);
+  void PushVariableName(const AstRawString* name) {
+    if (IsOpen() && name != ast_value_factory_->dot_result_string()) {
+      names_stack_.push_back(Name(name, kVariableName));
+    }
+  }
 
   // Adds a function to infer name for.
-  void AddFunction(FunctionLiteral* func_to_infer) {
+  void AddFunction(FunctionLiteral func_to_infer) {
     if (IsOpen()) {
       funcs_to_infer_.push_back(func_to_infer);
     }
@@ -82,7 +103,13 @@ class FuncNameInferrer {
     if (IsOpen() && !funcs_to_infer_.empty()) funcs_to_infer_.pop_back();
   }
 
-  void RemoveAsyncKeywordFromEnd();
+  void RemoveAsyncKeywordFromEnd() {
+    if (IsOpen()) {
+      CHECK_GT(names_stack_.size(), 0);
+      CHECK(names_stack_.back().name()->IsOneByteEqualTo("async"));
+      names_stack_.pop_back();
+    }
+  }
 
   // Infers a function name and leaves names collection state.
   void Infer() {
@@ -110,14 +137,42 @@ class FuncNameInferrer {
   };
 
   // Constructs a full name in dotted notation from gathered names.
-  AstConsString* MakeNameFromStack();
+  AstConsString* MakeNameFromStack() {
+    if (names_stack_.size() == 0) {
+      return ast_value_factory_->empty_cons_string();
+    }
+    AstConsString* result = ast_value_factory_->NewConsString();
+    auto it = names_stack_.begin();
+    while (it != names_stack_.end()) {
+      // Advance the iterator to be able to peek the next value.
+      auto current = it++;
+      // Skip consecutive variable declarations.
+      if (it != names_stack_.end() && current->type() == kVariableName &&
+          it->type() == kVariableName) {
+        continue;
+      }
+      // Add name. Separate names with ".".
+      Zone* zone = ast_value_factory_->zone();
+      if (!result->IsEmpty()) {
+        result->AddString(zone, ast_value_factory_->dot_string());
+      }
+      result->AddString(zone, current->name());
+    }
+    return result;
+  }
 
   // Performs name inferring for added functions.
-  void InferFunctionsNames();
+  void InferFunctionsNames() {
+    AstConsString* func_name = MakeNameFromStack();
+    for (FunctionLiteral func : funcs_to_infer_) {
+      func->set_raw_inferred_name(func_name);
+    }
+    funcs_to_infer_.resize(0);
+  }
 
   AstValueFactory* ast_value_factory_;
   std::vector<Name> names_stack_;
-  std::vector<FunctionLiteral*> funcs_to_infer_;
+  std::vector<FunctionLiteral> funcs_to_infer_;
   size_t scope_depth_ = 0;
 
   DISALLOW_COPY_AND_ASSIGN(FuncNameInferrer);
diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
index 88c738479a..c56df016e7 100644
--- a/src/parsing/parser-base.h
+++ b/src/parsing/parser-base.h
@@ -233,6 +233,8 @@ class ParserBase {
   using FuncNameInferrerState = typename Types::FuncNameInferrer::State;
   using SourceRange = typename Types::SourceRange;
   using SourceRangeScope = typename Types::SourceRangeScope;
+  using AstValueFactory = typename Types::AstValueFactory;
+  using AstRawString = typename Types::AstRawString;
 
   // All implementation-specific methods must be called through this.
   Impl* impl() { return static_cast<Impl*>(this); }
@@ -759,7 +761,7 @@ class ParserBase {
 
   DeclarationScope* NewScriptScope(REPLMode repl_mode) const {
     return new (zone())
-        DeclarationScope(zone(), ast_value_factory(), repl_mode);
+        DeclarationScope(zone(), ast_value_factory()->this_string(), repl_mode);
   }
 
   DeclarationScope* NewVarblockScope() const {
@@ -810,7 +812,10 @@ class ParserBase {
 
     // TODO(verwaest): Move into the DeclarationScope constructor.
     if (!IsArrowFunction(kind)) {
-      result->DeclareDefaultFunctionVariables(ast_value_factory());
+      result->DeclareDefaultFunctionVariables(
+        ast_value_factory()->this_string(),
+        ast_value_factory()->new_target_string(),
+        ast_value_factory()->this_function_string());
     }
     return result;
   }
@@ -4241,7 +4246,7 @@ void ParserBase<Impl>::ParseFunctionBody(
     // Declare arguments after parsing the function since lexical 'arguments'
     // masks the arguments object. Declare arguments before declaring the
     // function var since the arguments object masks 'function arguments'.
-    function_scope->DeclareArguments(ast_value_factory());
+    function_scope->DeclareArguments(ast_value_factory()->arguments_string());
   }
 
   impl()->DeclareFunctionNameVar(function_name, function_syntax_kind,
@@ -4580,7 +4585,7 @@ typename ParserBase<Impl>::ExpressionT ParserBase<Impl>::ParseClassLiteral(
 
   if (class_info.requires_brand) {
     class_scope->DeclareBrandVariable(
-        ast_value_factory(), IsStaticFlag::kNotStatic, kNoSourcePosition);
+        ast_value_factory()->dot_brand_string(), IsStaticFlag::kNotStatic, kNoSourcePosition);
   }
 
   bool should_save_class_variable_index =
diff --git a/src/parsing/parser.cc b/src/parsing/parser.cc
index 63b8b9c6f9..c128046431 100644
--- a/src/parsing/parser.cc
+++ b/src/parsing/parser.cc
@@ -58,13 +58,14 @@ FunctionLiteral* Parser::DefaultConstructor(const AstRawString* name,
       bool is_optional = false;
       Variable* constructor_args = function_scope->DeclareParameter(
           constructor_args_name, VariableMode::kTemporary, is_optional, is_rest,
-          ast_value_factory(), pos);
+          ast_value_factory()->arguments_string(), pos);
 
       Expression* call;
       {
         ScopedPtrList<Expression> args(pointer_buffer());
+        VariableProxy* proxy = factory()->NewVariableProxy(constructor_args);
         Spread* spread_args = factory()->NewSpread(
-            factory()->NewVariableProxy(constructor_args), pos, pos);
+            factory()->NewVariableProxyExpression(proxy), pos, pos);
 
         args.Add(spread_args);
         Expression* super_call_ref = NewSuperCallReference(pos);
@@ -283,26 +284,30 @@ Expression* Parser::NewSuperPropertyReference(int pos) {
   // this_function[home_object_symbol]
   VariableProxy* this_function_proxy =
       NewUnresolved(ast_value_factory()->this_function_string(), pos);
+  VariableProxyExpression* this_function_proxy_expr = factory()->NewVariableProxyExpression(this_function_proxy);
   Expression* home_object_symbol_literal = factory()->NewSymbolLiteral(
       AstSymbol::kHomeObjectSymbol, kNoSourcePosition);
   Expression* home_object = factory()->NewProperty(
-      this_function_proxy, home_object_symbol_literal, pos);
+      this_function_proxy_expr, home_object_symbol_literal, pos);
   return factory()->NewSuperPropertyReference(home_object, pos);
 }
 
 Expression* Parser::NewSuperCallReference(int pos) {
   VariableProxy* new_target_proxy =
       NewUnresolved(ast_value_factory()->new_target_string(), pos);
+  VariableProxyExpression* new_target_proxy_expr = factory()->NewVariableProxyExpression(new_target_proxy);
   VariableProxy* this_function_proxy =
       NewUnresolved(ast_value_factory()->this_function_string(), pos);
-  return factory()->NewSuperCallReference(new_target_proxy, this_function_proxy,
+  VariableProxyExpression* this_function_proxy_expr = factory()->NewVariableProxyExpression(this_function_proxy);
+  return factory()->NewSuperCallReference(new_target_proxy_expr, this_function_proxy_expr,
                                           pos);
 }
 
 Expression* Parser::NewTargetExpression(int pos) {
   auto proxy = NewUnresolved(ast_value_factory()->new_target_string(), pos);
-  proxy->set_is_new_target();
-  return proxy;
+  auto proxy_expr = factory()->NewVariableProxyExpression(proxy);
+  proxy_expr->set_is_new_target();
+  return proxy_expr;
 }
 
 Expression* Parser::ImportMetaExpression(int pos) {
@@ -762,7 +767,7 @@ void Parser::ParseREPLProgram(ParseInfo* info, ScopedPtrList<Statement>* body,
   // For a REPL script this is the completion value of the
   // script instead of the expression of some "return" statement. The
   // completion value of the script is obtained by manually invoking
-  // the {Rewriter} which will return a VariableProxy referencing the
+  // the {Rewriter} which will return a VariableProxyExpression referencing the
   // result.
   DCHECK(flags().is_repl_mode());
   this->scope()->SetLanguageMode(info->language_mode());
@@ -777,7 +782,7 @@ void Parser::ParseREPLProgram(ParseInfo* info, ScopedPtrList<Statement>* body,
 
   if (has_error()) return;
 
-  base::Optional<VariableProxy*> maybe_result =
+  base::Optional<VariableProxyExpression*> maybe_result =
       Rewriter::RewriteBody(info, scope, block->statements());
   Expression* result_value =
       (maybe_result && *maybe_result)
@@ -1322,9 +1327,10 @@ Statement* Parser::ParseExportDefault() {
       VariableProxy* proxy =
           DeclareBoundVariable(local_name, VariableMode::kConst, pos);
       proxy->var()->set_initializer_position(position());
+      VariableProxyExpression* proxy_expr = factory()->NewVariableProxyExpression(proxy);
 
       Assignment* assignment = factory()->NewAssignment(
-          Token::INIT, proxy, value, kNoSourcePosition);
+          Token::INIT, proxy_expr, value, kNoSourcePosition);
       result = IgnoreCompletion(
           factory()->NewExpressionStatement(assignment, kNoSourcePosition));
 
@@ -1613,10 +1619,11 @@ Statement* Parser::DeclareClass(const AstRawString* variable_name,
   VariableProxy* proxy =
       DeclareBoundVariable(variable_name, VariableMode::kLet, class_token_pos);
   proxy->var()->set_initializer_position(end_pos);
+  VariableProxyExpression* proxy_expr = factory()->NewVariableProxyExpression(proxy);
   if (names) names->Add(variable_name, zone());
 
   Assignment* assignment =
-      factory()->NewAssignment(Token::INIT, proxy, value, class_token_pos);
+      factory()->NewAssignment(Token::INIT, proxy_expr, value, class_token_pos);
   return IgnoreCompletion(
       factory()->NewExpressionStatement(assignment, kNoSourcePosition));
 }
@@ -1632,10 +1639,11 @@ Statement* Parser::DeclareNative(const AstRawString* name, int pos) {
   // introduced dynamically when we meet their declarations, whereas
   // other functions are set up when entering the surrounding scope.
   VariableProxy* proxy = DeclareBoundVariable(name, VariableMode::kVar, pos);
+  VariableProxyExpression* proxy_expr = factory()->NewVariableProxyExpression(proxy);
   NativeFunctionLiteral* lit =
       factory()->NewNativeFunctionLiteral(name, extension_, kNoSourcePosition);
   return factory()->NewExpressionStatement(
-      factory()->NewAssignment(Token::INIT, proxy, lit, kNoSourcePosition),
+      factory()->NewAssignment(Token::INIT, proxy_expr, lit, kNoSourcePosition),
       pos);
 }
 
@@ -1658,8 +1666,9 @@ Expression* Parser::RewriteReturn(Expression* return_value, int pos) {
 
     // temp = expr
     Variable* temp = NewTemporary(ast_value_factory()->empty_string());
+    VariableProxy* proxy = factory()->NewVariableProxy(temp);
     Assignment* assign = factory()->NewAssignment(
-        Token::ASSIGN, factory()->NewVariableProxy(temp), return_value, pos);
+        Token::ASSIGN, factory()->NewVariableProxyExpression(proxy), return_value, pos);
 
     // temp === undefined
     Expression* is_undefined = factory()->NewCompareOperation(
@@ -1672,7 +1681,7 @@ Expression* Parser::RewriteReturn(Expression* return_value, int pos) {
     // ParseFunctionBody.
     return_value =
         factory()->NewConditional(is_undefined, factory()->ThisExpression(),
-                                  factory()->NewVariableProxy(temp), pos);
+                                  factory()->NewVariableProxyExpression(proxy), pos);
   }
   return return_value;
 }
@@ -1698,8 +1707,9 @@ Statement* Parser::RewriteSwitchStatement(SwitchStatement* switch_statement,
   Expression* tag = switch_statement->tag();
   Variable* tag_variable =
       NewTemporary(ast_value_factory()->dot_switch_tag_string());
+  VariableProxy* tag_variable_proxy = factory()->NewVariableProxy(tag_variable);
   Assignment* tag_assign = factory()->NewAssignment(
-      Token::ASSIGN, factory()->NewVariableProxy(tag_variable), tag,
+      Token::ASSIGN, factory()->NewVariableProxyExpression(tag_variable_proxy), tag,
       tag->position());
   // Wrap with IgnoreCompletion so the tag isn't returned as the completion
   // value, in case the switch statements don't have a value.
@@ -1707,7 +1717,7 @@ Statement* Parser::RewriteSwitchStatement(SwitchStatement* switch_statement,
       factory()->NewExpressionStatement(tag_assign, kNoSourcePosition));
   switch_block->statements()->Add(tag_statement, zone());
 
-  switch_statement->set_tag(factory()->NewVariableProxy(tag_variable));
+  switch_statement->set_tag(factory()->NewVariableProxyExpression(tag_variable_proxy));
   Block* cases_block = factory()->NewBlock(1, false);
   cases_block->statements()->Add(switch_statement, zone());
   cases_block->set_scope(scope);
@@ -1734,8 +1744,9 @@ void Parser::InitializeVariables(
 Block* Parser::RewriteCatchPattern(CatchInfo* catch_info) {
   DCHECK_NOT_NULL(catch_info->pattern);
 
+  VariableProxy* catch_info_variable_proxy = factory()->NewVariableProxy(catch_info->variable);
   DeclarationParsingResult::Declaration decl(
-      catch_info->pattern, factory()->NewVariableProxy(catch_info->variable));
+      catch_info->pattern, factory()->NewVariableProxyExpression(catch_info_variable_proxy));
 
   ScopedPtrList<Statement> init_statements(pointer_buffer());
   InitializeVariables(&init_statements, NORMAL_VARIABLE, &decl);
@@ -1851,9 +1862,9 @@ void Parser::ParseAndRewriteAsyncGeneratorFunctionBody(
   Block* catch_block;
   {
     ScopedPtrList<Expression> reject_args(pointer_buffer());
-    reject_args.Add(factory()->NewVariableProxy(
-        function_state_->scope()->generator_object_var()));
-    reject_args.Add(factory()->NewVariableProxy(catch_scope->catch_variable()));
+    reject_args.Add(factory()->NewVariableProxyExpression(factory()->NewVariableProxy(
+        function_state_->scope()->generator_object_var())));
+    reject_args.Add(factory()->NewVariableProxyExpression(factory()->NewVariableProxy(catch_scope->catch_variable())));
 
     Expression* reject_call = factory()->NewCallRuntime(
         Runtime::kInlineAsyncGeneratorReject, reject_args, kNoSourcePosition);
@@ -1874,7 +1885,7 @@ void Parser::ParseAndRewriteAsyncGeneratorFunctionBody(
     ScopedPtrList<Expression> close_args(pointer_buffer());
     VariableProxy* call_proxy = factory()->NewVariableProxy(
         function_state_->scope()->generator_object_var());
-    close_args.Add(call_proxy);
+    close_args.Add(factory()->NewVariableProxyExpression(call_proxy));
     close_call = factory()->NewCallRuntime(Runtime::kInlineGeneratorClose,
                                            close_args, kNoSourcePosition);
   }
@@ -1921,14 +1932,14 @@ Block* Parser::RewriteForVarInLegacy(const ForInfo& for_info) {
   const DeclarationParsingResult::Declaration& decl =
       for_info.parsing_result.declarations[0];
   if (!IsLexicalVariableMode(for_info.parsing_result.descriptor.mode) &&
-      decl.initializer != nullptr && decl.pattern->IsVariableProxy()) {
+      decl.initializer != nullptr && decl.pattern->IsVariableProxyExpression()) {
     ++use_counts_[v8::Isolate::kForInInitializer];
-    const AstRawString* name = decl.pattern->AsVariableProxy()->raw_name();
+    const AstRawString* name = decl.pattern->AsVariableProxyExpression()->raw_name();
     VariableProxy* single_var = NewUnresolved(name);
     Block* init_block = factory()->NewBlock(2, true);
     init_block->statements()->Add(
         factory()->NewExpressionStatement(
-            factory()->NewAssignment(Token::ASSIGN, single_var,
+            factory()->NewAssignment(Token::ASSIGN, factory()->NewVariableProxyExpression(single_var),
                                      decl.initializer, decl.value_beg_pos),
             kNoSourcePosition),
         zone());
@@ -1960,14 +1971,14 @@ void Parser::DesugarBindingInForEachStatement(ForInfo* for_info,
   Variable* temp = NewTemporary(ast_value_factory()->dot_for_string());
   ScopedPtrList<Statement> each_initialization_statements(pointer_buffer());
   DCHECK_IMPLIES(!has_error(), decl.pattern != nullptr);
-  decl.initializer = factory()->NewVariableProxy(temp, for_info->position);
+  decl.initializer = factory()->NewVariableProxyExpression(factory()->NewVariableProxy(temp, for_info->position));
   InitializeVariables(&each_initialization_statements, NORMAL_VARIABLE, &decl);
 
   *body_block = factory()->NewBlock(3, false);
   (*body_block)
       ->statements()
       ->Add(factory()->NewBlock(true, each_initialization_statements), zone());
-  *each_variable = factory()->NewVariableProxy(temp, for_info->position);
+  *each_variable = factory()->NewVariableProxyExpression(factory()->NewVariableProxy(temp, for_info->position));
 }
 
 // Create a TDZ for any lexically-bound names in for in/of statements.
@@ -2045,10 +2056,12 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
   //   make statement: temp_x = x.
   for (const AstRawString* bound_name : for_info.bound_names) {
     VariableProxy* proxy = NewUnresolved(bound_name);
+    VariableProxyExpression* proxy_expr = factory()->NewVariableProxyExpression(proxy);
     Variable* temp = NewTemporary(temp_name);
     VariableProxy* temp_proxy = factory()->NewVariableProxy(temp);
-    Assignment* assignment = factory()->NewAssignment(Token::ASSIGN, temp_proxy,
-                                                      proxy, kNoSourcePosition);
+    VariableProxyExpression* temp_proxy_expr = factory()->NewVariableProxyExpression(temp_proxy);
+    Assignment* assignment = factory()->NewAssignment(Token::ASSIGN, temp_proxy_expr,
+                                                      proxy_expr, kNoSourcePosition);
     Statement* assignment_statement =
         factory()->NewExpressionStatement(assignment, kNoSourcePosition);
     outer_block->statements()->Add(assignment_statement, zone());
@@ -2060,9 +2073,10 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
   if (next) {
     first = NewTemporary(temp_name);
     VariableProxy* first_proxy = factory()->NewVariableProxy(first);
+    VariableProxyExpression* first_proxy_expr = factory()->NewVariableProxyExpression(first_proxy);
     Expression* const1 = factory()->NewSmiLiteral(1, kNoSourcePosition);
     Assignment* assignment = factory()->NewAssignment(
-        Token::ASSIGN, first_proxy, const1, kNoSourcePosition);
+        Token::ASSIGN, first_proxy_expr, const1, kNoSourcePosition);
     Statement* assignment_statement =
         factory()->NewExpressionStatement(assignment, kNoSourcePosition);
     outer_block->statements()->Add(assignment_statement, zone());
@@ -2096,10 +2110,12 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
       VariableProxy* proxy = DeclareBoundVariable(
           for_info.bound_names[i], for_info.parsing_result.descriptor.mode,
           kNoSourcePosition);
+      VariableProxyExpression* proxy_expr = factory()->NewVariableProxyExpression(proxy);
       inner_vars.Add(proxy->var());
       VariableProxy* temp_proxy = factory()->NewVariableProxy(temps.at(i));
+      VariableProxyExpression* temp_proxy_expr = factory()->NewVariableProxyExpression(temp_proxy);
       Assignment* assignment = factory()->NewAssignment(
-          Token::INIT, proxy, temp_proxy, kNoSourcePosition);
+          Token::INIT, proxy_expr, temp_proxy_expr, kNoSourcePosition);
       Statement* assignment_statement =
           factory()->NewExpressionStatement(assignment, kNoSourcePosition);
       int declaration_pos = for_info.parsing_result.descriptor.declaration_pos;
@@ -2116,16 +2132,18 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
       {
         Expression* const1 = factory()->NewSmiLiteral(1, kNoSourcePosition);
         VariableProxy* first_proxy = factory()->NewVariableProxy(first);
-        compare = factory()->NewCompareOperation(Token::EQ, first_proxy, const1,
+        VariableProxyExpression* first_proxy_expr = factory()->NewVariableProxyExpression(first_proxy);
+        compare = factory()->NewCompareOperation(Token::EQ, first_proxy_expr, const1,
                                                  kNoSourcePosition);
       }
       Statement* clear_first = nullptr;
       // Make statement: first = 0.
       {
         VariableProxy* first_proxy = factory()->NewVariableProxy(first);
+        VariableProxyExpression* first_proxy_expr = factory()->NewVariableProxyExpression(first_proxy);
         Expression* const0 = factory()->NewSmiLiteral(0, kNoSourcePosition);
         Assignment* assignment = factory()->NewAssignment(
-            Token::ASSIGN, first_proxy, const0, kNoSourcePosition);
+            Token::ASSIGN, first_proxy_expr, const0, kNoSourcePosition);
         clear_first =
             factory()->NewExpressionStatement(assignment, kNoSourcePosition);
       }
@@ -2138,9 +2156,10 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
     // Make statement: flag = 1.
     {
       VariableProxy* flag_proxy = factory()->NewVariableProxy(flag);
+      VariableProxyExpression* flag_proxy_expr = factory()->NewVariableProxyExpression(flag_proxy);
       Expression* const1 = factory()->NewSmiLiteral(1, kNoSourcePosition);
       Assignment* assignment = factory()->NewAssignment(
-          Token::ASSIGN, flag_proxy, const1, kNoSourcePosition);
+          Token::ASSIGN, flag_proxy_expr, const1, kNoSourcePosition);
       Statement* assignment_statement =
           factory()->NewExpressionStatement(assignment, kNoSourcePosition);
       ignore_completion_block->statements()->Add(assignment_statement, zone());
@@ -2162,7 +2181,8 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
     {
       Expression* const1 = factory()->NewSmiLiteral(1, kNoSourcePosition);
       VariableProxy* flag_proxy = factory()->NewVariableProxy(flag);
-      flag_cond = factory()->NewCompareOperation(Token::EQ, flag_proxy, const1,
+      VariableProxyExpression* flag_proxy_expr = factory()->NewVariableProxyExpression(flag_proxy);
+      flag_cond = factory()->NewCompareOperation(Token::EQ, flag_proxy_expr, const1,
                                                  kNoSourcePosition);
     }
 
@@ -2173,8 +2193,9 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
       // Make expression: flag = 0.
       {
         VariableProxy* flag_proxy = factory()->NewVariableProxy(flag);
+        VariableProxyExpression* flag_proxy_expr = factory()->NewVariableProxyExpression(flag_proxy);
         Expression* const0 = factory()->NewSmiLiteral(0, kNoSourcePosition);
-        compound_next = factory()->NewAssignment(Token::ASSIGN, flag_proxy,
+        compound_next = factory()->NewAssignment(Token::ASSIGN, flag_proxy_expr,
                                                  const0, kNoSourcePosition);
       }
 
@@ -2182,10 +2203,12 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
       int inner_var_proxy_pos = scanner()->location().beg_pos;
       for (int i = 0; i < for_info.bound_names.length(); i++) {
         VariableProxy* temp_proxy = factory()->NewVariableProxy(temps.at(i));
+        VariableProxyExpression* temp_proxy_expr = factory()->NewVariableProxyExpression(temp_proxy);
         VariableProxy* proxy =
             factory()->NewVariableProxy(inner_vars.at(i), inner_var_proxy_pos);
+        VariableProxyExpression* proxy_expr = factory()->NewVariableProxyExpression(proxy);
         Assignment* assignment = factory()->NewAssignment(
-            Token::ASSIGN, temp_proxy, proxy, kNoSourcePosition);
+            Token::ASSIGN, temp_proxy_expr, proxy_expr, kNoSourcePosition);
         compound_next = factory()->NewBinaryOperation(
             Token::COMMA, compound_next, assignment, kNoSourcePosition);
       }
@@ -2208,7 +2231,8 @@ Statement* Parser::DesugarLexicalBindingsInForStatement(
       {
         Expression* const1 = factory()->NewSmiLiteral(1, kNoSourcePosition);
         VariableProxy* flag_proxy = factory()->NewVariableProxy(flag);
-        compare = factory()->NewCompareOperation(Token::EQ, flag_proxy, const1,
+        VariableProxyExpression* flag_proxy_expr = factory()->NewVariableProxyExpression(flag_proxy);
+        compare = factory()->NewCompareOperation(Token::EQ, flag_proxy_expr, const1,
                                                  kNoSourcePosition);
       }
       Statement* stop =
@@ -2297,7 +2321,7 @@ void Parser::AddArrowFunctionFormalParameters(
     parameters->has_rest = true;
   }
   DCHECK_IMPLIES(parameters->is_simple, !is_rest);
-  DCHECK_IMPLIES(parameters->is_simple, expr->IsVariableProxy());
+  DCHECK_IMPLIES(parameters->is_simple, expr->IsVariableProxyExpression());
 
   Expression* initializer = nullptr;
   if (expr->IsAssignment()) {
@@ -2667,13 +2691,13 @@ Block* Parser::BuildParameterInitializationBlock(
   int index = 0;
   for (auto parameter : parameters.params) {
     Expression* initial_value =
-        factory()->NewVariableProxy(parameters.scope->parameter(index));
+        factory()->NewVariableProxyExpression(factory()->NewVariableProxy(parameters.scope->parameter(index)));
     if (parameter->initializer() != nullptr) {
       // IS_UNDEFINED($param) ? initializer : $param
 
       auto condition = factory()->NewCompareOperation(
           Token::EQ_STRICT,
-          factory()->NewVariableProxy(parameters.scope->parameter(index)),
+          factory()->NewVariableProxyExpression(factory()->NewVariableProxy(parameters.scope->parameter(index))),
           factory()->NewUndefinedLiteral(kNoSourcePosition), kNoSourcePosition);
       initial_value =
           factory()->NewConditional(condition, parameter->initializer(),
@@ -2717,9 +2741,9 @@ Block* Parser::BuildRejectPromiseOnException(Block* inner_block,
   Expression* reject_promise;
   {
     ScopedPtrList<Expression> args(pointer_buffer());
-    args.Add(factory()->NewVariableProxy(
-        function_state_->scope()->generator_object_var()));
-    args.Add(factory()->NewVariableProxy(catch_scope->catch_variable()));
+    args.Add(factory()->NewVariableProxyExpression(factory()->NewVariableProxy(
+        function_state_->scope()->generator_object_var())));
+    args.Add(factory()->NewVariableProxyExpression(factory()->NewVariableProxy(catch_scope->catch_variable())));
     args.Add(factory()->NewBooleanLiteral(function_state_->CanSuspend(),
                                           kNoSourcePosition));
     reject_promise = factory()->NewCallRuntime(
@@ -2743,8 +2767,8 @@ Block* Parser::BuildRejectPromiseOnException(Block* inner_block,
 }
 
 Expression* Parser::BuildInitialYield(int pos, FunctionKind kind) {
-  Expression* yield_result = factory()->NewVariableProxy(
-      function_state_->scope()->generator_object_var());
+  Expression* yield_result = factory()->NewVariableProxyExpression(factory()->NewVariableProxy(
+      function_state_->scope()->generator_object_var()));
   // The position of the yield is important for reporting the exception
   // caused by calling the .throw method on a generator suspended at the
   // initial yield (i.e. right after generator instantiation).
@@ -3054,9 +3078,11 @@ void Parser::InsertShadowingVarBindingInitializers(Block* inner_block) {
     Variable* parameter = function_scope->LookupLocal(name);
     if (parameter == nullptr) continue;
     VariableProxy* to = NewUnresolved(name);
+    VariableProxyExpression* to_expr = factory()->NewVariableProxyExpression(to);
     VariableProxy* from = factory()->NewVariableProxy(parameter);
+    VariableProxyExpression* from_expr = factory()->NewVariableProxyExpression(from);
     Expression* assignment =
-        factory()->NewAssignment(Token::ASSIGN, to, from, kNoSourcePosition);
+        factory()->NewAssignment(Token::ASSIGN, to_expr, from_expr, kNoSourcePosition);
     Statement* statement =
         factory()->NewExpressionStatement(assignment, kNoSourcePosition);
     inner_block->statements()->InsertAt(0, statement, zone());
@@ -3245,14 +3271,16 @@ Expression* Parser::SpreadCall(Expression* function,
     } else {
       Variable* temp = NewTemporary(ast_value_factory()->empty_string());
       VariableProxy* obj = factory()->NewVariableProxy(temp);
+      VariableProxyExpression* obj_expr = factory()->NewVariableProxyExpression(obj);
       Assignment* assign_obj = factory()->NewAssignment(
-          Token::ASSIGN, obj, function->AsProperty()->obj(), kNoSourcePosition);
+          Token::ASSIGN, obj_expr, function->AsProperty()->obj(), kNoSourcePosition);
       function =
           factory()->NewProperty(assign_obj, function->AsProperty()->key(),
                                  kNoSourcePosition, optional_chain);
       args.Add(function);
       obj = factory()->NewVariableProxy(temp);
-      args.Add(obj);
+      obj_expr = factory()->NewVariableProxyExpression(obj);
+      args.Add(obj_expr);
     }
   } else {
     // Non-method calls
@@ -3373,8 +3401,8 @@ void Parser::SetFunctionNameFromPropertyName(ObjectLiteralProperty* property,
 
 void Parser::SetFunctionNameFromIdentifierRef(Expression* value,
                                               Expression* identifier) {
-  if (!identifier->IsVariableProxy()) return;
-  SetFunctionName(value, identifier->AsVariableProxy()->raw_name());
+  if (!identifier->IsVariableProxyExpression()) return;
+  SetFunctionName(value, identifier->AsVariableProxyExpression()->raw_name());
 }
 
 void Parser::SetFunctionName(Expression* value, const AstRawString* name,
@@ -3408,7 +3436,7 @@ Statement* Parser::CheckCallable(Variable* var, Expression* error, int pos) {
   Statement* validate_var;
   {
     Expression* type_of = factory()->NewUnaryOperation(
-        Token::TYPEOF, factory()->NewVariableProxy(var), nopos);
+        Token::TYPEOF, factory()->NewVariableProxyExpression(factory()->NewVariableProxy(var)), nopos);
     Expression* function_literal = factory()->NewStringLiteral(
         ast_value_factory()->function_string(), nopos);
     Expression* condition = factory()->NewCompareOperation(
diff --git a/src/parsing/parser.h b/src/parsing/parser.h
index 472c9a71ab..19e757b06b 100644
--- a/src/parsing/parser.h
+++ b/src/parsing/parser.h
@@ -61,13 +61,13 @@ struct ParserFormalParameters : FormalParametersBase {
 
     Parameter* next_parameter = nullptr;
     bool is_simple() const {
-      return pattern->IsVariableProxy() && initializer() == nullptr &&
+      return pattern->IsVariableProxyExpression() && initializer() == nullptr &&
              !is_rest();
     }
 
     const AstRawString* name() const {
       DCHECK(is_simple());
-      return pattern->AsVariableProxy()->raw_name();
+      return pattern->AsVariableProxyExpression()->raw_name();
     }
 
     Parameter** next() { return &next_parameter; }
@@ -120,9 +120,11 @@ struct ParserTypes<Parser> {
   using Factory = AstNodeFactory;
 
   // Other implementation-specific functions.
-  using FuncNameInferrer = v8::internal::FuncNameInferrer;
+  using FuncNameInferrer = v8::internal::FuncNameInferrer<ParserTypes<Parser>>;
   using SourceRange = v8::internal::SourceRange;
   using SourceRangeScope = v8::internal::SourceRangeScope;
+  using AstValueFactory = v8::internal::AstValueFactory;
+  using AstRawString = AstRawString;
 };
 
 class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
@@ -552,17 +554,17 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   // inside a variable proxy).  We exclude the case of 'this', which
   // has been converted to a variable proxy.
   V8_INLINE static bool IsIdentifier(Expression* expression) {
-    VariableProxy* operand = expression->AsVariableProxy();
+    VariableProxyExpression* operand = expression->AsVariableProxyExpression();
     return operand != nullptr && !operand->is_new_target();
   }
 
   V8_INLINE static const AstRawString* AsIdentifier(Expression* expression) {
     DCHECK(IsIdentifier(expression));
-    return expression->AsVariableProxy()->raw_name();
+    return expression->AsVariableProxyExpression()->raw_name();
   }
 
-  V8_INLINE VariableProxy* AsIdentifierExpression(Expression* expression) {
-    return expression->AsVariableProxy();
+  V8_INLINE VariableProxyExpression* AsIdentifierExpression(Expression* expression) {
+    return expression->AsVariableProxyExpression();
   }
 
   V8_INLINE bool IsConstructor(const AstRawString* identifier) const {
@@ -580,8 +582,8 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
 
   V8_INLINE bool IsNative(Expression* expr) const {
     DCHECK_NOT_NULL(expr);
-    return expr->IsVariableProxy() &&
-           expr->AsVariableProxy()->raw_name() ==
+    return expr->IsVariableProxyExpression() &&
+           expr->AsVariableProxyExpression()->raw_name() ==
                ast_value_factory()->native_string();
   }
 
@@ -789,22 +791,24 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
 
   Expression* ExpressionFromLiteral(Token::Value token, int pos);
 
-  V8_INLINE VariableProxy* ExpressionFromPrivateName(
+  V8_INLINE VariableProxyExpression* ExpressionFromPrivateName(
       PrivateNameScopeIterator* private_name_scope, const AstRawString* name,
       int start_position) {
     VariableProxy* proxy = factory()->ast_node_factory()->NewVariableProxy(
         name, NORMAL_VARIABLE, start_position);
     private_name_scope->AddUnresolvedPrivateName(proxy);
-    return proxy;
+    VariableProxyExpression* proxy_expr = factory()->NewVariableProxyExpression(proxy);
+    return proxy_expr;
   }
 
-  V8_INLINE VariableProxy* ExpressionFromIdentifier(
+  V8_INLINE VariableProxyExpression* ExpressionFromIdentifier(
       const AstRawString* name, int start_position,
       InferName infer = InferName::kYes) {
     if (infer == InferName::kYes) {
       fni_.PushVariableName(name);
     }
-    return expression_scope()->NewVariable(name, start_position);
+    VariableProxy* proxy = expression_scope()->NewVariable(name, start_position);
+    return factory()->NewVariableProxyExpression(proxy);
   }
 
   V8_INLINE void DeclareIdentifier(const AstRawString* name,
@@ -871,7 +875,7 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
       scope->DeclareParameter(
           is_simple ? parameter->name() : ast_value_factory()->empty_string(),
           is_simple ? VariableMode::kVar : VariableMode::kTemporary,
-          is_optional, parameter->is_rest(), ast_value_factory(),
+          is_optional, parameter->is_rest(), ast_value_factory()->arguments_string(),
           parameter->position);
     }
   }
diff --git a/src/parsing/preparser.cc b/src/parsing/preparser.cc
index f9af109d81..31dba9474d 100644
--- a/src/parsing/preparser.cc
+++ b/src/parsing/preparser.cc
@@ -222,7 +222,7 @@ PreParser::PreParseResult PreParser::PreParseFunction(
       // 'arguments' masks the arguments object. Declare arguments before
       // declaring the function var since the arguments object masks 'function
       // arguments'.
-      function_scope->DeclareArguments(ast_value_factory());
+      function_scope->DeclareArguments(ast_value_factory()->arguments_string());
 
       DeclareFunctionNameVar(function_name, function_syntax_kind,
                              function_scope);
diff --git a/src/parsing/preparser.h b/src/parsing/preparser.h
index 5280e3d226..5f52d925a5 100644
--- a/src/parsing/preparser.h
+++ b/src/parsing/preparser.h
@@ -889,6 +889,8 @@ struct ParserTypes<PreParser> {
   using FuncNameInferrer = PreParserFuncNameInferrer;
   using SourceRange = PreParserSourceRange;
   using SourceRangeScope = PreParserSourceRangeScope;
+  using AstValueFactory = v8::internal::AstValueFactory;
+  using AstRawString = AstRawString;
 };
 
 
diff --git a/src/parsing/rewriter.cc b/src/parsing/rewriter.cc
index 942acf13f8..944c94dbb6 100644
--- a/src/parsing/rewriter.cc
+++ b/src/parsing/rewriter.cc
@@ -55,7 +55,8 @@ class Processor final : public AstVisitor<Processor> {
   Expression* SetResult(Expression* value) {
     result_assigned_ = true;
     VariableProxy* result_proxy = factory()->NewVariableProxy(result_);
-    return factory()->NewAssignment(Token::ASSIGN, result_proxy, value,
+    VariableProxyExpression* result_proxy_expr = factory()->NewVariableProxyExpression(result_proxy);
+    return factory()->NewAssignment(Token::ASSIGN, result_proxy_expr, value,
                                     kNoSourcePosition);
   }
 
@@ -253,12 +254,14 @@ void Processor::VisitTryFinallyStatement(TryFinallyStatement* node) {
     CHECK_NOT_NULL(closure_scope());
     Variable* backup = closure_scope()->NewTemporary(
         factory()->ast_value_factory()->dot_result_string());
-    Expression* backup_proxy = factory()->NewVariableProxy(backup);
-    Expression* result_proxy = factory()->NewVariableProxy(result_);
+    VariableProxy* backup_proxy = factory()->NewVariableProxy(backup);
+    VariableProxy* result_proxy = factory()->NewVariableProxy(result_);
+    VariableProxyExpression* backup_proxy_expr = factory()->NewVariableProxyExpression(backup_proxy);
+    VariableProxyExpression* result_proxy_expr = factory()->NewVariableProxyExpression(result_proxy);
     Expression* save = factory()->NewAssignment(
-        Token::ASSIGN, backup_proxy, result_proxy, kNoSourcePosition);
+        Token::ASSIGN, backup_proxy_expr, result_proxy_expr, kNoSourcePosition);
     Expression* restore = factory()->NewAssignment(
-        Token::ASSIGN, result_proxy, backup_proxy, kNoSourcePosition);
+        Token::ASSIGN, result_proxy_expr, backup_proxy_expr, kNoSourcePosition);
     node->finally_block()->statements()->InsertAt(
         0, factory()->NewExpressionStatement(save, kNoSourcePosition), zone());
     node->finally_block()->statements()->Add(
@@ -351,10 +354,10 @@ EXPRESSION_NODE_LIST(DEF_VISIT)
 
 
 // Declarations are never visited.
-#define DEF_VISIT(type) \
-  void Processor::Visit##type(type* expr) { UNREACHABLE(); }
-DECLARATION_NODE_LIST(DEF_VISIT)
-#undef DEF_VISIT
+// #define DEF_VISIT(type) \
+//   void Processor::Visit##type(type* expr) { UNREACHABLE(); }
+// DECLARATION_NODE_LIST(DEF_VISIT)
+// #undef DEF_VISIT
 
 
 // Assumes code has been parsed.  Mutates the AST, so the AST should not
@@ -381,7 +384,7 @@ bool Rewriter::Rewrite(ParseInfo* info) {
   return RewriteBody(info, scope, body).has_value();
 }
 
-base::Optional<VariableProxy*> Rewriter::RewriteBody(
+base::Optional<VariableProxyExpression*> Rewriter::RewriteBody(
     ParseInfo* info, Scope* scope, ZonePtrList<Statement>* body) {
   DisallowHeapAllocation no_allocation;
   DisallowHandleAllocation no_handles;
@@ -400,12 +403,13 @@ base::Optional<VariableProxy*> Rewriter::RewriteBody(
       int pos = kNoSourcePosition;
       VariableProxy* result_value =
           processor.factory()->NewVariableProxy(result, pos);
+      VariableProxyExpression* result_value_expr = processor.factory()->NewVariableProxyExpression(result_value);
       if (!info->flags().is_repl_mode()) {
         Statement* result_statement =
-            processor.factory()->NewReturnStatement(result_value, pos);
+            processor.factory()->NewReturnStatement(result_value_expr, pos);
         body->Add(result_statement, info->zone());
       }
-      return result_value;
+      return result_value_expr;
     }
 
     if (processor.HasStackOverflow()) {
diff --git a/src/parsing/rewriter.h b/src/parsing/rewriter.h
index e820c0e53b..d01500d659 100644
--- a/src/parsing/rewriter.h
+++ b/src/parsing/rewriter.h
@@ -19,7 +19,7 @@ class Parser;
 class DeclarationScope;
 class Scope;
 class Statement;
-class VariableProxy;
+class VariableProxyExpression;
 
 class Rewriter {
  public:
@@ -35,7 +35,7 @@ class Rewriter {
   // rewrite the body but then use the ".result" VariableProxy to resolve
   // the async promise that is the result of running a REPL script.
   // Returns base::nullopt in case something went wrong.
-  static base::Optional<VariableProxy*> RewriteBody(
+  static base::Optional<VariableProxyExpression*> RewriteBody(
       ParseInfo* info, Scope* scope, ZonePtrList<Statement>* body);
 };
 
diff --git a/src/parsing/scanner.cc b/src/parsing/scanner.cc
index 1dc047d6e7..6151a25c87 100644
--- a/src/parsing/scanner.cc
+++ b/src/parsing/scanner.cc
@@ -998,29 +998,29 @@ Maybe<int> Scanner::ScanRegExpFlags() {
   return Just<int>(flags);
 }
 
-const AstRawString* Scanner::CurrentSymbol(
-    AstValueFactory* ast_value_factory) const {
-  if (is_literal_one_byte()) {
-    return ast_value_factory->GetOneByteString(literal_one_byte_string());
-  }
-  return ast_value_factory->GetTwoByteString(literal_two_byte_string());
-}
-
-const AstRawString* Scanner::NextSymbol(
-    AstValueFactory* ast_value_factory) const {
-  if (is_next_literal_one_byte()) {
-    return ast_value_factory->GetOneByteString(next_literal_one_byte_string());
-  }
-  return ast_value_factory->GetTwoByteString(next_literal_two_byte_string());
-}
-
-const AstRawString* Scanner::CurrentRawSymbol(
-    AstValueFactory* ast_value_factory) const {
-  if (is_raw_literal_one_byte()) {
-    return ast_value_factory->GetOneByteString(raw_literal_one_byte_string());
-  }
-  return ast_value_factory->GetTwoByteString(raw_literal_two_byte_string());
-}
+// const AstRawString* Scanner::CurrentSymbol(
+//     AstValueFactory* ast_value_factory) const {
+//   if (is_literal_one_byte()) {
+//     return ast_value_factory->GetOneByteString(literal_one_byte_string());
+//   }
+//   return ast_value_factory->GetTwoByteString(literal_two_byte_string());
+// }
+
+// const AstRawString* Scanner::NextSymbol(
+//     AstValueFactory* ast_value_factory) const {
+//   if (is_next_literal_one_byte()) {
+//     return ast_value_factory->GetOneByteString(next_literal_one_byte_string());
+//   }
+//   return ast_value_factory->GetTwoByteString(next_literal_two_byte_string());
+// }
+
+// const AstRawString* Scanner::CurrentRawSymbol(
+//     AstValueFactory* ast_value_factory) const {
+//   if (is_raw_literal_one_byte()) {
+//     return ast_value_factory->GetOneByteString(raw_literal_one_byte_string());
+//   }
+//   return ast_value_factory->GetTwoByteString(raw_literal_two_byte_string());
+// }
 
 
 double Scanner::DoubleValue() {
diff --git a/src/parsing/scanner.h b/src/parsing/scanner.h
index 830067e1ad..23b3dd1da2 100644
--- a/src/parsing/scanner.h
+++ b/src/parsing/scanner.h
@@ -323,11 +323,31 @@ class V8_EXPORT_PRIVATE Scanner {
     return LiteralContainsEscapes(next());
   }
 
-  const AstRawString* CurrentSymbol(AstValueFactory* ast_value_factory) const;
+  template<typename AstValueFactoryT>
+  const AstRawString* CurrentSymbol(AstValueFactoryT* ast_value_factory) const {
+    if (is_literal_one_byte()) {
+      return ast_value_factory->GetOneByteString(literal_one_byte_string());
+    }
+    return ast_value_factory->GetTwoByteString(literal_two_byte_string());
+  }
 
-  const AstRawString* NextSymbol(AstValueFactory* ast_value_factory) const;
+  template<typename AstValueFactoryT>
+  const AstRawString* NextSymbol(
+      AstValueFactoryT* ast_value_factory) const {
+    if (is_next_literal_one_byte()) {
+      return ast_value_factory->GetOneByteString(next_literal_one_byte_string());
+    }
+    return ast_value_factory->GetTwoByteString(next_literal_two_byte_string());
+  }
+
+  template<typename AstValueFactoryT>
   const AstRawString* CurrentRawSymbol(
-      AstValueFactory* ast_value_factory) const;
+      AstValueFactoryT* ast_value_factory) const {
+    if (is_raw_literal_one_byte()) {
+      return ast_value_factory->GetOneByteString(raw_literal_one_byte_string());
+    }
+    return ast_value_factory->GetTwoByteString(raw_literal_two_byte_string());
+  }
 
   double DoubleValue();
 
